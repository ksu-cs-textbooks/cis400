---
title: "Syllabus"
pre: "7. "
weight: 70
date: 2018-08-24T10:53:26-05:00
---

{{% notice noiframe %}}
This textbook was authored for the **CIS 400 - Object-Oriented Design, Implementation, and Testing** course at Kansas State University.  This front matter is specific to that course.  If you are not enrolled in the course, please disregard this section.
{{% /notice %}}

## CIS 400 - Object-Oriented Design, Implementation, and Testing

### Class Meeting Times and Locations
* **Section A**: M 1:30pm-3:20pm DUF 1092
* **Section B**: W 1:30pm-3:20pm DUF 1092
* **Section S**: F 1:30pm-3:20pm DUF 1092

### Instructor Contact Information
* **Instructor:** Nathan Bean (nhbean AT ksu DOT edu)
* **Office:** DUE 2216
* **Phone:** (785)483-9264 (Call/Text)
* **Website:** [https://nathanhbean.com](https://nathanhbean.com)
* **Office Hours:** TBD
* **Virtual Office Hours:** By appointment via [Zoom](ksu.zoom.us).  Schedule a meeting via email or Discord.

### Preferred Methods of Communication:
* **Chat:** Quick questions via Discord are the preferred means of communication.   Questions whose answers may benefit the class I would encourage you to post in the` #cis400` channel, as this keeps a public history your classmates can review.  More personal questions should be direct messaged to `@Nathan Bean`.
* **Email:** For questions outside of this course, email to nhbean@ksu.edu is preferred.
* **Phone/Text:** 785-483-9264 _Emergencies only!_ I will do my best to respond as quickly as I can.

### Prerequisites
* CIS 300

_Students may enroll in CIS courses only if they have earned a grade of C or better for each prerequisite to these courses._

### Course Overview
A study of concepts and techniques used to produce quality software programs. Object-oriented concepts, models, execution environments, design and testing techniques. Extensive application of these concepts and techniques to the development of non-trivial software programs.

### Course Description
This course is focused on helping you to learn the concepts and skills needed to develop high-quality software. Along the way you will have ample opportunities to practice these skills developing non-trivial software projects. These are not the “baby programs” of early CS coursework, but rather applications that could be used in a production environment.

Accordingly, our goal is not just to write software that compiles without errors, but to develop **_well-written and maintainable software_**. This goal demands extra attention to design, documentation, and testing. Additionally, we will explore some of the powerful features of the
C# Language and the Visual Studio compiler, as well as other professional tools like Git and Visio.

### Course Objectives
By the end of this course, we expect each student to be able to:
* Create class definitions that 1) utilize **encapsulation** to organize related data and
behavior, 2) prevent uncontrolled internal state changes through **information hiding**, and 3)
allow outside code controlled interactions through **message passing**.
* **Specify** expected object behavior and verify it through creating and executing **unit tests**
against a class definition.
* Utilize **polymorphism** in the form of **inheritance** to minimize code duplication by moving shared fields and methods to a common ancestor.
* Reason about **dynamic dispatch** to determine what version of a polymorphic function or method will be invoked at runtime.
* Utilize **developer tools** like Visual Studio and Git to develop software reliably and efficiently.

### Major Course Topics
* Encapsulation and data hiding
* Message passing
* Polymorphism and inheritance
* Dynamic Dispatch
* Event-based programming
* Testing
* Debugging
* Software Versioning
* Code Modularization

### Course Structure
A common axiom in learner-centered teaching is **_“(s)he who does the work does the learning.”_** What this really means is that students primarily learn through grappling with the concepts and skills of a course while attempting to apply them. Simply seeing a demonstration or hearing a lecture by itself doesn’t do much in terms of learning. This is not to say that they don’t serve an important role - as they set the stage for the learning to come, helping you to recognize the core ideas to focus on as you work. The work itself consists of applying ideas, practicing skills, and putting the concepts into your own words.

This course is built around learner-centered teaching and its recognition of the role and importance of these different aspects of learning. Most class periods will consist of short lectures interspersed with a variety of hands-on activities built around the concepts and skills we are seeking to master. In addition, we will be applying these ideas in iteratively building a series of related software applications over the course of the semester. Part of our class time will be reserved for working on these applications, giving you the chance to ask questions and receive feedback from your instructors, UTAs, and classmates.

### The Work
There is no shortcut to becoming a great programmer. Only by **_doing the work_** will you develop the skills and knowledge to make your a successful computer scientist. This course is built around that principle, and gives you ample opportunity to do the work, with as much support as we can offer.

#### Tutorials
Each module will include many tutorial assignments that will take you step-by-step through using a particular concept or technique.  The point is not simply to complete the tutorial, but to _practice_ the technique and coding involved.  You will be expected to implement these techniques on your own in the milestone assignment of the module - so this practice helps prepare you for those assignments.

#### Milestone Programming Assignments
Throughout the semester you will be building a non-trivial software project iteratively; every week a new milestone (a collection of features embodying a new version of a software application) will be due. Each milestone builds upon the prior milestone’s code base, so it is critical that you complete each milestone in a timely manner! This process also reflects the way software development is done in the real world - breaking large projects into more readily achievable milestones helps manage the development process.

Following along that real-world theme, programming assignments in this class will also be graded according to their conformance to coding style, documentation, and testing requirements. Each milestone’s rubric will include points assigned to each of these factors. It is not enough to simply write code that compiles and meets the specification; good code is readable, maintainable, efficient, and secure. The principles and practices of Object-Oriented programming that we will be learning in this course have been developed specifically to help address these concerns.

#### Exams
Over the course of the semester we will have a total of four exams. The primary purpose of these exams is formative; they are intended to help us (me as the instructor and you as the student) evaluate how you are learning the material. Thus, my testing policies may differ greatly from your prior courses.

These exams will cover the vocabulary and concepts we are learning and involve reasoning about object-oriented programming, including some code writing. The purpose of this style of assessment to assess your ability to recognize the problem and conceive an appropriate solution.  Hence, you are encouraged to annotate your answers with comments, describing your reasoning as you tackle the problem. Additionally, I will include a “certainty scale” for each question, and would ask that you mark how confident you are in your answer. Doing these extra steps helps me know how well you are grasping the material, and helps both of us to know what concepts and skills may need more work.

The first exam is a _pretest_ that is used to help establish your knowledge and readiness coming into the course.  You will earn a **100%** for completing this exam, regardless of your correct or incorrect responses.

The second three exams are _midterms_, which cover the content immediately proceeding them. You will have a chance to correct mistakes you have made in thee exams, potentially earning back your full points.

The _final_ exam is comprehensive, and covers the most important topics and skills we have developed in the course.  This is considered a _summative_ test (one that measures your mastery of a subject).  It will count for twice the number of points as the earlier exams, and you will not have a chance to correct mistakes made on it.

### Grading
In theory, each student begins the course with an A. As you submit work, you can either maintain your A (for good work) or chip away at it (for less adequate or incomplete work). In practice, each student starts with 0 points in the gradebook and works upward toward a final point total out of the possible number of points. In this course, it is perfectly possible to get an A simply by completing all the software milestones in a satisfactory manner and attending and participating in class each day. In such a case, the examinations will simply reflect the learning you’ve been doing through that work. Each work category constitutes a portion of the final grade, as detailed below:

30% - Activities, Tutorials, and Quizzes (The lowest 4 scores are dropped)

36% - Programming Assignment Milestones (3.6% each, 11 milestones total; The single lowest assignment score will be dropped)

34% - Exams (8.5% each, with the final worth double at 17; 4 exams total)

Letter grades will be assigned following the standard scale:
90% - 100% - A; 80% - 89.99% - B; 70% - 79.99% - C; 60% - 69.99% - D; 00% - 59.99% - F

At the end of the semester, for students who have earned a borderline grade (i.e. a 89.98%, which is a B), I will bump their grade to the next highest letter grade based on the student’s completion of exam annotations and confidence ratings on exam questions. That is to say, if the example student regularly gives detailed annotations of their thought process, and rates their confidence in their answer, I will bump their 89.98% to an A. Students who do not provide annotations and confidence ratings will not be bumped, for any reason.

### Collaboration
Collaboration is an important practice for both learning and software development. As such, you are encouraged to work with peers and seek out help from your instructors and UTAs. However, it is also critical to remember that **_(s)he who does the work, does the learning._**  Relying too much on your peers will deny you the opportunity to learn yourself. As the skills we
are working on are the foundations on which all future computer science coursework relies, any skills you fail to develop in this course can have long-ranging effects on your future success, in both classes and the working world.

Determining where the line between good collaboration and over-reliance on others can be challenging, especially as a student. I offer a few guidelines that can help:
1.  If you can’t yet put a concept into your own words and explain it to someone not versed in programming, you do not yet have a full grasp of the concept. Don’t be tempted to use someone else’s words - keep working at it until you can use your own. But “working at it” in this context can mean seeking out additional explanations from other people. Sometimes getting enough different perspectives on a concept is what you need to be
able to synthesize your own.
2. Directly copying another student’s code and turning it in as your own work is never acceptable. It is a form of plagiarism and constitutes academic dishonesty and can result in severe penalties (covered below). This does not mean you can’t discuss the assignment and approaches to solving it with your peers - in fact doing so is often a useful learning practice. Just keep those discussions above the code level.
3. As a corollary to point 2, it is okay to ask another student to look at your code when you are struggling with syntax or errors. However, don’t let them correct it for you - let them offer suggestions but make any changes yourself. The act of making these changes actually contributes to the stimulus your brain is using to develop programming skills. So don’t let others shortchange your opportunity to learn (including instructors and UTAs).

### Late Work
{{% notice warning %}}
Read the late work policy very carefully! If you are unsure how to interpret it, please contact the instructor via email. Not understanding the policy does not mean that it won't apply to you!
{{% /notice %}}

Every student should strive to turn in work on time. Late work will receive a penalty of 10% of the possible points for each day it is late. Missed class attendance cannot be made up, though as mentioned above some areas will drop the lowest two scores. If you are getting behind in the class, you are encouraged to speak to the instructor for options to make up missed work.

### Software
We will be using Visual Studio 2019 as our development environment. You can download a free copy of Visual Studio Community for your own machine at
[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/). You should also be able to get a professional
development license through your Azure Student Portal. See the CS support documentation for details: [https://support.cs.ksu.edu/CISDocs/wiki/FAQ#MSDNAA](https://support.cs.ksu.edu/CISDocs/wiki/FAQ#MSDNAA)

Additionally, we will create UML diagrams using Microsoft Visio, which can also be downloaded from the Azure Student Portal (see above).

We will use Xamarin workbooks to distribute some content. This free software can be downlaoded from: [https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install)

Discord also offers some free desktop and mobile clients that you may prefer over the web client.  You may download them from: [https://discord.com/download](https://discord.com/download).


### Recommended Texts & Supplies
To participate in this course, students must have access to a modern web browser and broadband internet connection. All course materials will be provided via Canvas. Modules may also contain links to external resources for additional information, such as programming language documentation.

This course offers an instructor-written textbook, which is broken up into a specific reading order and interleaved with activities and quizzes in the modules. It can also be directly accessed at [{{< param textbookURL >}}]({{< param textbookURL >}}).

Students who would like additional textbooks should refer to resources available on the [O'Riley For Higher Education](https://go.oreilly.com/kansas-state-university) digital library offered by the Kansas State University Library.  These include electronic editions of popular textbooks as well as videos and tutorials.

### Subject to Change
The details in this syllabus are not set in stone. Due to the flexible nature of this class, adjustments may need to be made as the semester progresses, though they will be kept to a minimum. If any changes occur, the changes will be posted on the Canvas page for this course and emailed to all students.

{{% include "themes/ksucs-hugo-theme/static/files/syllabus-no-copyright.md" %}} 

### Copyright Notice
©2021 The materials in this online course fall under the protection of all intellectual property, copyright and trademark laws of the U.S. The digital materials included here come with the legal permissions and releases of the copyright holders. These course materials should be used for educational purposes only; the contents should not be distributed electronically or otherwise beyond the confines of this online course. The URLs listed here do not suggest endorsement of either the site owners or the contents found at the sites. Likewise, mentioned brands (products and services) do not suggest endorsement. Students own copyright to what they create.

Original content in the course textbook at [{{< param textbookURL >}}]({{< param textbookURL >}}) is licensed under a Creative Commons BY-SA license by Nathan Bean unless otherwise stated.

