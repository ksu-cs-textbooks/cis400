<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Is it Working Yet?"><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing :: K-State CIS 400 Textbook"><meta name=twitter:description content="Is it Working Yet?"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/1-object-orientation/04-testing/"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Testing :: K-State CIS 400 Textbook"><meta property="og:description" content="Is it Working Yet?"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Testing :: K-State CIS 400 Textbook"><meta itemprop=description content="Is it Working Yet?"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:29:34-05:00"><meta itemprop=wordCount content="4"><title>Testing :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/1-object-orientation/04-testing/ rel=canonical type=text/html title="Testing :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/04-testing/index.xml rel=alternate type=application/rss+xml title="Testing :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/04-testing/tele.html rel=alternate type=text/html title="Testing :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/04-testing/embed.html rel=alternate type=text/html title="Testing :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1728334428 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1728334428 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1728334428 rel=stylesheet><link href=/cis400/css/auto-complete.css?1728334428 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1728334428 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1728334428 rel=stylesheet><link href=/cis400/css/fonts.css?1728334428 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1728334428 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1728334428 rel=stylesheet><link href=/cis400/css/theme-auto.css?1728334428 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-auto.css?1728334428 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1728334428 rel=stylesheet><link href=/cis400/css/print.css?1728334428 rel=stylesheet media=print><link href=/cis400/css/format-print.css?1728334428 rel=stylesheet><script src=/cis400/js/variant.js?1728334428></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1728334428 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis400/1-object-orientation/04-testing/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis400/1-object-orientation/><span itemprop=name>Object-Orientation</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Testing</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/1-object-orientation/03-documentation/05-summary/ title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/1-object-orientation/04-testing/01-introduction/ title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 4</div><h1 id=testing>Testing</h1><p>Is it Working Yet?</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Testing</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>A critical part of the software development process is <em>ensuring the software works!</em> We mentioned earlier that it is possible to logically prove that software works by constructing a state transition table for the program, but once a program reaches a certain size this strategy becomes less feasible. Similarly, it is possible to model a program mathematically and construct a theorem that <em>proves</em> it will perform as intended. But in practice, most software is validated through some form of <em>testing</em>. This chapter will discuss the process of testing object-oriented systems.</p><h2 id=key-terms>Key Terms</h2><p>Some key terms to learn in this chapter are:</p><ul><li>Informal Testing</li><li>Formal Testing</li><li>Test Plan</li><li>Test Framework</li><li>Automated Testing</li><li>Assertions</li><li>Unit tests</li><li>Testing Code Coverage</li><li>Regression Testing</li></ul><h2 id=key-skills>Key Skills</h2><p>The key skill to learn in this chapter is how to write C# unit test code using <a href=https://xunit.net/ rel=external target=_blank>xUnit</a> and the Visual Studio <a href="https://docs.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2019" rel=external target=_blank>Test Explorer</a>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=manual-testing>Manual Testing</h1><p>As you&rsquo;ve developed programs, you&rsquo;ve probably run them, supplied input, and observed if what happened was what you wanted. This process is known as <em>informal testing</em>. It&rsquo;s informal, because you don&rsquo;t have a set procedure you follow, i.e. what specific inputs to use, and what results to expect. <em>Formal testing</em> adds that structure. In a formal test, you would have a written procedure to follow, which specifies <em>exactly</em> what inputs to supply, and what results should be expected. This written procedure is known as a <em>test plan</em>.</p><p>Historically, the test plan was often developed at the same time as the design for the software (but before the actual programming). The programmers would then build the software to match the design, and the completed software and the test plan would be passed onto a testing team that would follow the step-by-step testing procedures laid out in the testing plan. When a test failed, they would make a detailed record of the failure, and the software would be sent back to the programmers to fix.</p><p>This model of software development has often been referred to as the &lsquo;waterfall model&rsquo; as each task depends on the one before it:</p><p><a href=#R-image-0b36d888000d254c1591abc5dbd1cadd class=lightbox-link><img alt="The Waterfall Model of Software Development" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.2.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-0b36d888000d254c1591abc5dbd1cadd><img alt="The Waterfall Model of Software Development" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.2.1.png></a></p><p>Unfortunately, as this model is often implemented, the programmers responsible for writing the software are reassigned to other projects as the software moves into the testing phase. Rather than employ valuable programmers as testers, most companies will hire less expensive workers to carry out the testing. So either a skeleton crew of programmers is left to fix any errors that are found during the tests, or these are passed back to programmers already deeply involved in a new project.</p><p>The costs involved in fixing software errors also grow larger the longer the error exists in the software. The table below comes from a NASA report of software error costs throughout the project life cycle: <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p><a href=#R-image-68bf38c1a8a25e2cb152a1669cc042ce class=lightbox-link><img alt="Comparison of System Cost Factors Excluding Operations" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.2.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-68bf38c1a8a25e2cb152a1669cc042ce><img alt="Comparison of System Cost Factors Excluding Operations" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.2.2.png></a></p><p>It is clear from the graph and the paper that the cost to fix a software error grows exponentially if the fix is delayed. You probably have instances in your own experience that also speak to this - have you ever had a bug in a program you didn&rsquo;t realize was there until your project was nearly complete? How hard was it to fix, compared to an error you found and fixed right away?</p><p>It was realizations like these, along with growing computing power that led to the development of <em>automated testing</em>, which we&rsquo;ll discuss next.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Jonette M. Stecklein, Jim Dabney, Brandon Dick, Bill Haskins, Randy Lovell, and Gregory Maroney. <a href=https://ntrs.nasa.gov/citations/20100036670 rel=external target=_blank>&ldquo;Error Cost Escalation Through the Project Life Cycle&rdquo;</a>, NASA, June 19, 2014.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=automated-testing>Automated Testing</h1><p>Automated testing is the practice of using a program to test another program. Much as a compiler is a program that translates a program from a higher-order language into a lower-level form, a test program executes a test plan against the program being tested. And much like you must supply the program to be compiled, for automated testing you must supply the tests that need to be executed. In many ways the process of writing automated tests is like writing a manual test plan - you are writing instructions of what to try, and what the results should be. The difference is with a manual test plan, you are writing these instructions for a human. With an automated test plan, you are writing them for a program.</p><p>Automated tests are typically categorized as <em>unit</em>, <em>integration</em>, and <em>system</em> tests:</p><ul><li><strong>Unit tests</strong> focus on a single unit of code, and test it in isolation from other parts of the code. In object-oriented programs where code is grouped into objects, these are the units that are tested. Thus, for each class you would have a corresponding file of unit tests.</li><li><strong>Integration</strong> tests focus on the interaction of units working together, and with infrastructure external to the program (i.e. databases, other programs, etc).</li><li><strong>System</strong> tests look at the entire program&rsquo;s behavior.</li></ul><p>The complexity of writing tests scales with each of these categories. Emphasis is usually put on writing unit tests, especially as the classes they test are written. By testing these classes early, errors can be located and fixed quickly.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=writing-tests>Writing Tests</h1><p>Writing tests is in many ways just as challenging and creative an endeavor as writing programs. Tests usually consist of invoking some portion of program code, and then using <em>assertions</em> to determine that the actual results match the expected results. The results of these assertions are typically reported on a per-test basis, which makes it easy to see where your program is not behaving as expected.</p><p>Consider a class that is a software control system for a kitchen stove. It might have properties for four burners, which correspond to what heat output they are currently set to. Let&rsquo;s assume this is as an integer between 0 (off) and 5 (high). When we first construct this class, we&rsquo;d probably expect them all to be off! A test to verify that expectation would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>StoveTests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Fact]</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=k>void</span> <span class=n>BurnersShouldBeOffAtInitialization</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Stove</span> <span class=n>stove</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Stove</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerOne</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerTwo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerThree</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerFour</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Here we&rsquo;ve written the test using the C# <a href=https://xunit.net/ rel=external target=_blank>xUnit</a> test framework, which is being adopted by Microsoft as their preferred framework, replacing the <a href=https://nunit.org/ rel=external target=_blank>nUnit</a> test framework (there are many other C# test frameworks, but these two are the most used).</p><p>Notice that the test is simply a method, defined in a class. This is very common for test frameworks, which tend to be written using the same programming language the programs they test are written in (which makes it easier for one programmer to write both the code unit and the code to test it). Above the class appears an <a href=https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/ rel=external target=_blank>attribute</a> - <code>[Fact]</code>. Attributes are a way of supplying metadata within C# code. This metadata can be used by the compiler and other programs to determine how it works with your code. In this case, it indicates to the xUnit test runner that this method is a test.</p><p>Inside the method, we create an instance of stove, and then use the <code>Assert.Equal&lt;T>(T expected, T actual)</code> method to determine that the actual and expected values match. If they do, the assertion is marked as passing, and the test runner will display this pass. If it fails, the test runner will report the failure, along with details to help find and fix the problem (what value was expected, what it actually was, and which test contained the assertion).</p><p>The xUnit framework provides for two kinds of tests, <em>Facts</em>, which are written as functions that have no parameters, and <em>Theories</em>, which do have parameters. The values for these parameters are supplied with another attribute, typically <code>[InlineData]</code>. For example, we might test that when we set a burner to a setting within the valid 0-5 range, it is set to that value:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Theory]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(0)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(1)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(2)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(3)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(4)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(5)]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>ShouldBeAbleToSetBurnerOneToValidRange</span><span class=p>(</span><span class=kt>int</span> <span class=n>setting</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stove</span> <span class=n>stove</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Stove</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>stove</span><span class=p>.</span><span class=n>BurnerOne</span> <span class=p>=</span> <span class=n>setting</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=n>setting</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerOne</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The values in the parentheses of the <code>InlineData</code> are the values supplied to the parameter list of the theory method. Thus, this test is actually <em>six</em> tests; each test makes sure that one of the settings is working. We could have done all six as separate assignments and assertions within a single fact, but using a theory means that if only one of these settings doesn&rsquo;t work, we will see that one test fail while the others pass. This level of specificity can be very helpful in finding errors.</p><p>So far our tests cover the expected behavior of our stove. But where tests really prove their worth is with the <em>edge cases</em> - those things we as programmers don&rsquo;t anticipate. For example, what happens if we try setting our range to a setting above 5? Should it simply clamp at 5? Should it not change from its current setting? Or should it shut itself off entirely because its user is clearly a pyromaniac bent on burning down their house? If the specification for our program doesn&rsquo;t say, it is up to us to decide. Let&rsquo;s say we expect it to be clamped at 5:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Theory]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(6)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(18)]</span>
</span></span><span class=line><span class=cl><span class=na>[InlineData(1000000)]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>BurnerOneShouldNotExceedASettingOfFive</span><span class=p>(</span><span class=kt>int</span> <span class=n>setting</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stove</span> <span class=n>stove</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Stove</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>stove</span><span class=p>.</span><span class=n>BurnerOne</span> <span class=p>=</span> <span class=n>setting</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=m>5</span><span class=p>,</span> <span class=n>stove</span><span class=p>.</span><span class=n>BurnerOne</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that we don&rsquo;t need to exhaustively test all numbers above 5 - it is sufficient to provide a representative sample, ideally the first value past 5 (6), and a few others. Also, now that we have defined our expected behavior, we should make sure the documentation of our BurnerOne property matches it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The setting of burner one </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;value&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// An integer between 0 (off) and 5 (high)</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/value&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// If a value higher than 5 is attempted, the burner will be set to 5</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=n>BurnerOne</span> <span class=p>{</span><span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;}</span></span></span></code></pre></div><p>This way, other programmers (and ourselves, if we visit this code years later) will know what the expected behavior is. We&rsquo;d also want to test the other edge cases: i.e. when the burner is set to a negative number.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Recognizing and testing for edge cases is a critical aspect of test writing. But it is also a difficult skill to develop, as we have a tendency to focus on expected values and expected use-cases for our software. But most serious errors occur when values outside these expectations are introduced. Also, remember special values, like <code>double.PositiveInfinity</code>, <code>double.NegativeInfinity</code>, and <code>double.NaN</code>.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=xunit-assertions>xUnit Assertions</h1><p>Like most testing frameworks, the xUnit framework provides a host of specialized assertions.</p><h2 id=boolean-assertions>Boolean Assertions</h2><p>For example, xUnit provides two boolean assertions:</p><ul><li><code>Assert.True(bool actual)</code>, asserts that the value supplied to the <code>actual</code> parameter is <code>true</code>.</li><li><code>Assert.False(bool actual)</code>, asserts that the value supplied to the <code>actual</code> parameter is <code>false</code>.</li></ul><p>While it may be tempting to use <code>Assert.True()</code> for all tests, i.e. <code>Assert.True(stove.BurnerOne == 0)</code>, it is better practice to use the specialized assertion that best matches the situation, in this case <code>Assert.Equal&lt;T>(T expected, T actual)</code> as a failing test will supply more details.</p><h2 id=equality-assertions>Equality Assertions</h2><p>The <code>Assert.Equal&lt;T>(T expected, T actual)</code> is the workhorse of the assertion library. Notice it is a template method, so it can be used with any type that is comparable (which is pretty much everything possible in C#). It also has an override, <code>Assert.Equal&lt;T>(T expected, T actual, int precision)</code> which allows you to specify the precision for floating-point numbers. Remember that floating point error can cause two calculated values to be slightly different than one another; specifying a precision allows you to say just how close to the expected an actual value needs to be to be considered &rsquo;equal&rsquo; for the purposes of the test.</p><p>Like most assertions, it is paired with an opposite, <code>Assert.NotEqual&lt;T>(T expected, T actual)</code>, which also has an override for supplying precision.</p><h2 id=numeric-assertions>Numeric Assertions</h2><p>With numeric values, it can be handy to determine if the value falls within a range:</p><ul><li><code>Assert.InRange&lt;T>(T actual, T low, T high)</code> asserts <code>actual</code> falls between <code>low</code> and <code>high</code> (inclusive), and</li><li><code>Assert.NotInRange&lt;T>(T actual, T low, T high)</code> asserts <code>actual</code> does not fall between <code>low</code> and <code>high</code> (inclusive)</li></ul><h2 id=reference-assertions>Reference Assertions</h2><p>There are special assertions to deal with null references:</p><ul><li><code>Assert.Null(object object)</code> asserts the supplied <code>object</code> is null, and</li><li><code>Assert.NotNull(object object)</code> asserts the supplied <code>object</code> is <em>not</em> null</li></ul><p>In addition, two objects may be considered equal, but may or may not be the same object (i.e. not referencing the same memory). This can be asserted with:</p><ul><li><code>Assert.Same(object expected, object actual)</code> asserts the <code>expected</code> and <code>actual</code> object references are to the same object, while</li><li><code>Assert.NotSame(object expected, object actual)</code> asserts the <code>expected</code> and <code>actual</code> object references are <em>not</em> the same object</li></ul><h2 id=type-assertions>Type Assertions</h2><p>At times, you may want to assure it is possible to cast an object to a specific type. This can be done with:</p><ul><li><code>Assert.IsAssignableFrom&lt;T>(object obj)</code>
Where <code>T</code> is the type to cast into.</li></ul><p>At other times, you may want to assert that the object is <em>exactly</em> the type you expect (.e. <code>T</code> is not an interface or base class of <code>obj</code>). That can be done with:</p><ul><li><code>Assert.IsType&lt;T>(object obj)</code></li></ul><h2 id=collection-assertions>Collection Assertions</h2><p>There are a host of assertions for working with collections:</p><ul><li><code>Assert.Empty(IEnumerable collection)</code> asserts that the collection is empty, while</li><li><code>Assert.NotEmpty(IEnumerable collection)</code> asserts that it is <em>not</em> empty</li><li><code>Assert.Contains&lt;T>(T expected, IEnumerable&lt;T> collection)</code> asserts that the <code>expected</code> item is found in the <code>collection</code>, while</li><li><code>Assert.DoesNotContain&lt;T>(T expected, IEnumerable&lt;T> collection)</code> asserts the <code>expected</code> item is <em>not</em> found in the <code>collection</code></li></ul><p>In addition to the simple equality check form of <code>Assert.Contains&lt;T>()</code> and <code>Assert.DoesNotContain&lt;T>()</code>, there is a version that takes a filter expression (an expression that evaluates to <code>true</code> or <code>false</code> indicating that an item was found) written as a lambda expression. For example, to determine if a list of <code>Fruit</code> contains an <code>Orange</code> we could use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=n>Fruit</span><span class=p>&gt;</span> <span class=n>fruits</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Fruit</span><span class=p>&gt;()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Orange</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Apple</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Grape</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>Banana</span><span class=p>()</span> <span class=p>{</span><span class=n>Overripe</span> <span class=p>=</span> <span class=kc>true</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Assert</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=n>fruits</span><span class=p>,</span> <span class=n>item</span> <span class=p>=&gt;</span> <span class=n>item</span> <span class=k>is</span> <span class=n>Orange</span><span class=p>);</span></span></span></code></pre></div><p>The expression <code>item is Orange</code> is run on each item in <code>fruits</code> until it evaluates to <code>true</code> or we run out of fruit to check. We can also supply curly braces with a return statement if we need to perform more complex logic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Assert</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=n>fruits</span><span class=p>,</span> <span class=n>item</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>item</span> <span class=k>is</span> <span class=n>Banana</span> <span class=n>banana</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>banana</span><span class=p>.</span><span class=n>Overripe</span><span class=p>)</span> <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span></span></span></code></pre></div><p>Here we only return <code>true</code> for overripe bananas. Using <code>Assert.Contains()</code> with a filter expression can be useful for checking that expected items are in a collection. To check that the collection also does not contain unexpected items, we can test the length of the collection against the expected number of values, i.e.:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Assert</span><span class=p>.</span><span class=n>True</span><span class=p>(</span><span class=n>fruits</span><span class=p>.</span><span class=n>Count</span> <span class=p>==</span> <span class=m>4</span><span class=p>,</span> <span class=s>$&#34;Expected 4 items but found {fruits.Count}&#34;</span><span class=p>);</span></span></span></code></pre></div><p>Here we use the <code>Assert.True()</code> overload that allows a custom message when the test fails.</p><p>Finally, <code>Assert.Collection&lt;T>(IEnumerable&lt;T> collection, Action&lt;T>[] inspectors)</code> can apply specific inspectors against each item in a collection. Using the same fruits list as above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Assert</span><span class=p>.</span><span class=n>Collection</span><span class=p>(</span><span class=n>fruits</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=p>=&gt;</span> <span class=n>Assert</span><span class=p>.</span><span class=n>IsType</span><span class=p>&lt;</span><span class=n>Orange</span><span class=p>&gt;(</span><span class=n>item</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=p>=&gt;</span> <span class=n>Assert</span><span class=p>.</span><span class=n>IsType</span><span class=p>&lt;</span><span class=n>Apple</span><span class=p>&gt;(</span><span class=n>item</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=p>=&gt;</span> <span class=n>Assert</span><span class=p>.</span><span class=n>IsType</span><span class=p>&lt;</span><span class=n>Grape</span><span class=p>&gt;(</span><span class=n>item</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>IsType</span><span class=p>&lt;</span><span class=n>Banana</span><span class=p>&gt;(</span><span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Assert</span><span class=p>.</span><span class=n>True</span><span class=p>(((</span><span class=n>Banana</span><span class=p>)</span><span class=n>item</span><span class=p>).</span><span class=n>Overripe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>);</span></span></span></code></pre></div><p>Here we use an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=netcore-3.1" rel=external target=_blank>Action<t> delegate</a> to map each item in the collection to an assertion. These actions are written using [lambda expressions], which are conceptually <em>functions</em>.</p><p>The number of actions should correspond to the expected size of the collection, and the items supplied to the actions <em>must be in the same order as they appear in the collection</em>. Thus, the <code>Assert.Collection()</code> is a good choice when the collection is expected to always be in the same order, while the <code>Assert.Contains()</code> approach allows for variation in the ordering.</p><h2 id=exception-assertions>Exception Assertions</h2><p>Error assertions <em>also</em> use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=netcore-3.1" rel=external target=_blank>Action<t> delegate</a>, in this case to execute code that is expected to throw an exception, i.e. we could test for <code>System.DivideByZeroException</code> with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>DivisionByZeroShouldThrowException</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=p>.</span><span class=n>Throws</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=n>DivideByZeroException</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>tmp</span> <span class=p>=</span> <span class=m>10.0</span><span class=p>/</span><span class=m>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note how we place the code that is expected to throw the exception <em>inside</em> the body of the Action? This allows the assertion to wrap it in a <code>try/catch</code> internally. The exception-related assertions are:</p><ul><li><code>Assert.Throws(System.Exception expectedException, Action testCode)</code> asserts the supplied <code>expectedException</code> is thrown when <code>testCode</code> is executed</li><li><code>Assert.Throws&lt;T>(Action testCode) where T : System.Exception</code> the templated version of the above</li><li><code>Assert.ThrowsAny&lt;T>(Action testCode) where T: System.Exception</code> asserts that <em>any</em> exception will be thrown by the <code>testCode</code> when executed</li></ul><p>There are also similar assertions for exceptions being thrown in <em>asynchronous</em> code. These operate nearly identically, except instead of supplying an Action, we supply a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1" rel=external target=_blank>Task</a>:</p><ul><li><code>Assert.ThrowsAsync&lt;T>(Task testCode) where T : System.Exception</code> asserts the supplied exception type <code>T</code> is thrown when <code>testCode</code> is executed</li><li><code>Assert.ThrowsAnyAsync&lt;T>(Task testCode) where T: System.Exception</code> is the asynchronous version of the previous assertion, asserts the supplied exception type <code>T</code> will be thrown some point after <code>testCode</code> is executed.</li></ul><h2 id=events-assertions>Events Assertions</h2><p>Asserting that events will be thrown also involves <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=netcore-3.1" rel=external target=_blank>Action<t> delegate</a>, and is a bit more involved as it requires <em>three</em>. The first delegate is for attaching the assertion-supplied event handler to the listener, the second for detaching it, and the third is for triggering the event with the actual code involved.</p><p>For example, assume we have a class, <code>Emailer</code>, with a method <code>SendEmail(string address, string body)</code> that should have an event handler <code>EmailSent</code> whose event args are <code>EmailSentEventArgs</code>. We could test that this class was actually raising this event with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>EmailerShouldRaiseEmailSentWhenSendingEmails</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>address</span> <span class=p>=</span> <span class=s>&#34;test@test.com&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>body</span> <span class=p>=</span> <span class=s>&#34;this is a test&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Emailer</span> <span class=n>emailer</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Emailer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=p>.</span><span class=n>Raises</span><span class=p>&lt;</span><span class=n>EmailSentEventArgs</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>        <span class=n>listener</span> <span class=p>=&gt;</span> <span class=n>emailer</span> <span class=p>+=</span> <span class=n>listener</span><span class=p>,</span> <span class=c1>// This action attaches the listener</span>
</span></span><span class=line><span class=cl>        <span class=n>listener</span> <span class=p>=&gt;</span> <span class=n>emailer</span> <span class=p>-=</span> <span class=n>listener</span><span class=p>,</span> <span class=c1>// This action detaches the listener </span>
</span></span><span class=line><span class=cl>        <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>emailer</span><span class=p>.</span><span class=n>SendEmail</span><span class=p>(</span><span class=n>address</span><span class=p>,</span> <span class=n>body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The various event assertions are:</p><ul><li><code>Assert.Raises&lt;T>(Action attach, Action detach, Action testCode)</code></li><li><code>Assert.RaisesAny&lt;T>(Action attach, Action detach, Action testCode)</code></li></ul><p>There are also similar assertions for events being raised by <em>asynchronous</em> code. These operate nearly identically, except instead of supplying an Action, we supply a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1" rel=external target=_blank>Task</a>:</p><ul><li><code>Assert.RaisesAsync&lt;T>(Action attach, Action detach, Task testCode)</code></li><li><code>Assert.RaisesAnyAsync&lt;T>(Action attach, Action detach, Task testCode)</code></li></ul><p>For examples of these assertions, see <a href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/03-events/10-testing-generic-events/ rel=external target=_blank>section 2.3.10</a></p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>XUnit does not directly support old-style events - those with a named event handler like <code>CollectionChangedEventHandler</code>, only those that use the templated form: <code>EventHandler&lt;CustomEventArgs></code> (with the exception of the <code>PropertyChanged</code> event, discussed below). For strategies to handle the older-style events, see <a href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/03-events/11-testing-custom-events/ rel=external target=_blank>section 2.3.11</a></p></div></div><h2 id=property-change-assertions>Property Change Assertions</h2><p>Because C# has deeply integrated the idea of &lsquo;Property Change&rsquo; notifications as part of its GUI frameworks (which we&rsquo;ll cover in a later chapter), it makes sense to have a special assertion to deal with this notification. Hence, the <code>Assert.PropertyChanged(INotifyPropertyChanged @object, string propertyName, Action testCode)</code>. Using it is simple - supply the object that implements the <code>INotifyPropertyChanged</code> interface as the first argument, the name of the property that will be changing as the second, and the Action delegate that will trigger the change as the third.</p><p>For example, if we had a <code>Profile</code> object with a <code>StatusMessage</code> property that we knew should trigger a notification when it changes, we could write our test as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>ProfileShouldNotifyOfStatusMessageChanges</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Profile</span> <span class=n>testProfile</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Profile</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=p>.</span><span class=n>PropertyChanged</span><span class=p>(</span><span class=n>testProfile</span><span class=p>,</span> <span class=s>&#34;StatusMessage&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=n>testProfile</span><span class=p>.</span><span class=n>StatusMessage</span> <span class=p>=</span> <span class=s>&#34;Hard at work&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>There is also a similar assertion for testing if a property is changed in <em>asynchronous</em> code. This operates nearly identically, except instead of supplying an Action, we supply a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=netcore-3.1" rel=external target=_blank>Task</a>:</p><ul><li><code>Assert.PropertyChangedAsync(INotifyPropertyChanged @object, string propertyName, Task testCode)</code></li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=mock-objects>Mock Objects</h1><p>One of the most important ideas behind unit testing is the idea that you are testing an object <em>in isolation</em> from other objects (This is in direct contrast to <em>integration testing</em>, where you are interested in how objects are working together).</p><p>But how do we test a class that has a strong dependency on another class? Let&rsquo;s consider the case of an Automated Teller Machine (ATM). If we designed its control system using an object-oriented language, one natural architecture would be to have classes representing the cash dispenser, card reader, keyboard, display, and user&rsquo;s bank accounts. Then we might coordinate each of these into a central object, representing the entire ATM.</p><p>Unit testing most of these classes would be straightforward, but how do we unit test the ATM class? It would have dependencies on each of the other classes. If we used normal instances of those, we&rsquo;d have no idea if the test was failing due to the ATM class or its dependency. This is where <em>mock objects</em> come into play.</p><p>We start by replacing each of the dependencies with an interface using the same method signatures, and we pass the dependencies through the ATM constructor. We make sure our existing classes implement the interface, and pass them into the ATM when we create it. Thus, this step doesn&rsquo;t change much about how our program operates - we&rsquo;re still using the same classes to do the same things.</p><p>But in our unit tests for the <code>ATM</code> class, we can create new classes that implement the interfaces and pass them into the ATM instance we are testing. These are our <em>mock</em> classes, because they &ldquo;fill in&rdquo; for the real classes. Typically, a mock class is much simpler than a real class, and exposes information we might need in our test. For example, our Display class might include a <code>DisplayText</code> method, so have it implement an <code>IDisplay</code> interface that lists <code>DisplayText</code>. Then our <code>MockDisplay</code> class might look like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>internal</span> <span class=k>class</span> <span class=nc>MockDisplay</span> <span class=p>:</span><span class=n>IDisplay</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>string</span> <span class=n>LastTextDisplayed</span> <span class=p>{</span><span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=k>void</span> <span class=n>DisplayText</span><span class=p>(</span><span class=kt>string</span> <span class=n>text</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LastTextDisplayed</span> <span class=p>=</span> <span class=n>text</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that our mock class implements the required method, <code>DisplayText</code>, but in a very different way than a real display would - it just holds onto the string and makes it accessible with a public property. That way, we could check its value in a test:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>ShouldDisplayGreetingOnStartup</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MockDisplay</span> <span class=n>md</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockDisplay</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockKeyboard</span> <span class=n>mk</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockKeyboard</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockCardReader</span> <span class=n>mcr</span><span class=p>=</span> <span class=k>new</span> <span class=n>MockCardReader</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockCashDispenser</span> <span class=n>mcd</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockCashDispenser</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Atm</span> <span class=n>atm</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Atm</span><span class=p>(</span><span class=n>md</span><span class=p>,</span> <span class=n>mk</span><span class=p>,</span> <span class=n>mcr</span><span class=p>,</span> <span class=n>mcd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=s>&#34;Hello ATM!&#34;</span><span class=p>,</span> <span class=n>md</span><span class=p>.</span><span class=n>LastTextDisplayed</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Given our knowledge of C#, the only way <code>md.LastTextDisplayed</code> would be the string specified was if the <code>ATM</code> class asked it to display the message when it was constructed. Thus, we know it will do the same with the real <code>DisplayScreen</code> class. And if we have also thoroughly unit tested the <code>DisplayScreen</code> class, then we have a strong basis for believing our system is built correctly.</p><p>This approach also allows us to test things that would normally be very difficult to do - for example, we can write a method to have a <code>MockCardReader</code> trigger a <code>CardInserted</code> event:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>internal</span> <span class=k>class</span> <span class=nc>MockCardReader</span> <span class=p>:</span> <span class=n>ICardReader</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=k>event</span> <span class=n>EventHandler</span><span class=p>&lt;</span><span class=n>CardInsertedEventArgs</span><span class=p>&gt;</span> <span class=n>CardInserted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=k>void</span> <span class=n>TriggerCardInserted</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CardInserted</span><span class=p>.</span><span class=n>Invoke</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=k>new</span> <span class=n>CardInsertedEventArgs</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Which allows us to check that the ATM prompts a user for a PIN once a card is inserted:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>ShouldPromptForPinOnCardInsert</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MockDisplay</span> <span class=n>md</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockDisplay</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockKeyboard</span> <span class=n>mk</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockKeyboard</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockCardReader</span> <span class=n>mcr</span><span class=p>=</span> <span class=k>new</span> <span class=n>MockCardReader</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>MockCashDispenser</span> <span class=n>mcd</span> <span class=p>=</span> <span class=k>new</span> <span class=n>MockCashDispenser</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Atm</span> <span class=n>atm</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Atm</span><span class=p>(</span><span class=n>md</span><span class=p>,</span> <span class=n>mk</span><span class=p>,</span> <span class=n>mcr</span><span class=p>,</span> <span class=n>mcd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>mcr</span><span class=p>.</span><span class=n>TriggerCardInserted</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Assert</span><span class=p>.</span><span class=n>Equal</span><span class=p>(</span><span class=s>&#34;Please enter your PIN:&#34;</span><span class=p>,</span> <span class=n>md</span><span class=p>.</span><span class=n>LastTextDisplayed</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Using mock objects like this can greatly simplify the test-writing process, and improve the quality and robustness of your unit tests.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=running-tests>Running Tests</h1><p>Tests are usually run with a <em>test runner</em>, a program that will execute the test code against the code to be tested. The exact mechanism involved depends on the testing framework.</p><p>The xUnit framework is offered as a set of Nuget packages:</p><ul><li>The <code>xunit</code> package contains the library code defining the <code>Assertion</code> class as well as the <code>[Fact]</code> and <code>[Test]</code> attributes.</li><li>The <code>xunit.runner.visualstudio</code> package contains the actual test runner</li></ul><p>As with other aspects of the .NET framework, the tools can be used at either the command line, or through Visual Studio integrations. The <a href=https://xunit.net/docs/getting-started/netcore/cmdline rel=external target=_blank>xunit documentation</a> describes the command line approach thoroughly, so we won&rsquo;t belabor it here. But be aware, if you want to do development in a Linux or Unix environment, you <em>must</em> use the command line, as there is no version of Visual Studio available for those platforms (there is however, a version available for the Mac OS).</p><p>When building tests with Visual Studio, you will typically begin by adding an xUnit Test Project to your existing solution. Using the wizard will automatically incorporate the necessary Nuget packages into the project. However, you will need to add the project to be tested to the Dependencies list of the test project to give it access to the assembly to be tested. You do this by right-clicking the &lsquo;Dependencies&rsquo; entry under the Test Project in Visual Studio, choosing &ldquo;Add Project Reference&rdquo;, and in the dialog that pops up, checking the checkbox next to the name of the project you are testing:</p><p><a href=#R-image-b1a95e67e1c516383dc84bfde5c0cc2d class=lightbox-link><img alt="Adding the project reference" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.6.1.gif style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b1a95e67e1c516383dc84bfde5c0cc2d><img alt="Adding the project reference" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.6.1.gif></a></p><p>To explore and run your tests, you can open the <a href="https://docs.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2019" rel=external target=_blank>Test Explorer</a> from the &ldquo;Test&rdquo; menu. If no tests appear, you may need to build the test project. This can be done by right-clicking the test project in the Solution Explorer and selecting &ldquo;Build&rdquo;, or by clicking the &ldquo;Run All&rdquo; button in the Test Explorer. The &ldquo;Run All&rdquo; button will run every test in the suite. Alternatively, you can run individual tests by clicking on them, and clicking the &ldquo;Run&rdquo; button.</p><p><a href=#R-image-e7eb592c7fc4a8054cbe2172f8c2f0be class=lightbox-link><img alt="Run and Run All buttons" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.6.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e7eb592c7fc4a8054cbe2172f8c2f0be><img alt="Run and Run All buttons" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.6.2.png></a></p><p>As tests complete, they will report their status - pass or fail - indicated by a green checkmark or red x next to the test name, as well as the time it took to run the test. There will also be a summary available with details about any failures that can be accessed by clicking the test name.</p><p><a href=#R-image-627fcdb916584cd9b39b8baebd24cea5 class=lightbox-link><img alt="Test Detail Summary" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.6.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-627fcdb916584cd9b39b8baebd24cea5><img alt="Test Detail Summary" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.6.3.png></a></p><p>Occasionally, your tests may not seem to finish, but get stuck running. If this happens, check the output panel, switching it from &ldquo;build&rdquo; to &ldquo;tests&rdquo;. Most likely your test process crashed because of an error in your test code, and the output reporting that error will be reported there.</p><p><a href=#R-image-7b6f039d73721069c4dce556423676d9 class=lightbox-link><img alt="Test Output in the Output Panel" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.6.4.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-7b6f039d73721069c4dce556423676d9><img alt="Test Output in the Output Panel" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.6.4.png></a></p><p>It is a good idea to run tests you&rsquo;ve written previously as you add to or refactor your code. This practice is known as <em>regression testing</em>, and can help you identify errors your changes introduce that break what had previously been working code. This is also one of the strongest arguments for writing test code rather than performing ad-hoc testing; automated tests are easy to repeat.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>In this chapter we learned about testing, both manually using test plans and automatically using a testing framework. We saw how the cost of fixing errors rises exponentially with how long they go undiscovered. We discussed how writing automated tests during the programming phase can help uncover these errors earlier, and how regression testing can help us find new errors introduced while adding to our programs.</p><p>We learned how to use xUnit and Visual Studio&rsquo;s Test Explorer to write and run tests on .NET programs. We explored a good chunk of xUnit&rsquo;s assertion library. We saw how to get Visual Studio to analyze our tests for code coverage, discussed this metric&rsquo;s value to evaluate our tests. We also explored mutation testing, and saw how it can help improve our tests.</p><p>As you move forward as a software developer, you&rsquo;ll want to incorporate testing into your code-writing efforts.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=test-code-coverage>Test Code Coverage</h1><p>The term <em>test code coverage</em> refers to how much of your program&rsquo;s code is executed as your tests run. It is a useful metric for evaluating the <em>depth</em> of your test, if not necessarily the quality. Basically, if your code is not executed in the test framework, it is not tested in any way. If it is executed, then at least <em>some</em> tests are looking at it. So aiming for a high code coverage is a good starting point for writing tests.</p><p>Much like Visual Studio provides a Test Explorer for running tests, it provides support for analyzing test coverage. We can access this from the &ldquo;Test&rdquo; menu, where we select the &ldquo;Analyze Code Coverage for All Tests&rdquo;.</p><p><a href=#R-image-a33d91bd5bfdea90af3e54522236745b class=lightbox-link><img alt="Code coverage command in the Test Menu" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.7.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a33d91bd5bfdea90af3e54522236745b><img alt="Code coverage command in the Test Menu" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.7.1.png></a></p><p>This will build and run all our tests, and as they run it will collect data about how many blocks of code are or are not executed. The results appear in the Code Coverage Results panel:</p><p><a href=#R-image-ef108990d0cc7a0fddd127a60be4d510 class=lightbox-link><img alt="Code Coverage results panel" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/1.4.7.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ef108990d0cc7a0fddd127a60be4d510><img alt="Code Coverage results panel" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/1.4.7.2.png></a></p><p>Be aware that there will always be some blocks that are not picked up in this analysis, so it is typical to shoot for a high percentage.</p><p>While test code coverage is a good starting point for evaluating your tests, it is simply a measure of quantity, not quality. It is easily possible for you to have all of your code covered by tests, but still miss errors. You need to carefully consider the edge cases - those unexpected and unanticipated ways your code might end up being used.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=mutation-testing>Mutation Testing</h1><p>At this point you may be asking how to determine if your tests are good. Mutation testing is one way of evaluating the quality of your tests. Effectively, mutation testing is a strategy that <em>mutates</em> your program, and then runs your tests. If the test fails against the mutated code, this suggests your test is good.</p><p>As a simplistic example, take this extremely simple class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>Doll</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span><span class=k>get</span><span class=p>;}</span> <span class=p>=</span> <span class=s>&#34;Molly&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>A mutation might change it to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>Doll</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span><span class=k>get</span><span class=p>;}</span> <span class=p>=</span> <span class=s>&#34;Mollycoddle&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We would expect that the test <code>TheDollsNameIsAlwaysMolly</code> would fail due to this mutation. If it doesn&rsquo;t, we probably need to revisit our test. Here is an example of a test that would both normally pass, and pass with this mutation. See if you can spot the problem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=na>[Fact]</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>TheDollsNameIsAlwaysMolly</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Doll</span> <span class=n>doll</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Doll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Assert</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=n>doll</span><span class=p>.</span><span class=n>Name</span><span class=p>,</span> <span class=s>&#34;Molly&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Mutation testing is done by a special testing tool that uses reflection to understand and alter the classes being tested in your unit tests. In C#, we use <a href=https://stryker-mutator.io/docs/stryker-net/introduction/ rel=external target=_blank>Stryker.NET</a>.</p><p>As with code coverage, mutation testing can&rsquo;t provide all the answers. But it does help ensure that our programs and the tests we write of them are more robust.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis400/commit/681e5c9c43e3ac6de614c2cc74487702fd43cab7>Aug 10, 2023</a></p></div></div><script src=/cis400/js/clipboard.min.js?1728334428 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1728334428 defer></script><script src=/cis400/js/theme.js?1728334428 defer></script></body></html>