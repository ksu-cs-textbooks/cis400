<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Advanced C# :: K-State CIS 400 Textbook</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/</link><description>For a Sharper Language</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 27 Jun 2024 14:36:54 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/01-introduction/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/01-introduction/</guid><description>Throughout the earlier chapters, we’ve focused on the theoretical aspects of Object-Orientation, and discussed how those are embodied in the C# language. Before we close this section though, it would be a good idea to recognize that C# is not just an object-oriented language, but actually draws upon many ideas and syntax approaches that are not very object-oriented at all!
In this chapter, we’ll examine many aspects of C# that fall outside of the object-oriented mold.</description></item><item><title>Production Languages</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/02-production-languages/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/02-production-languages/</guid><description>It is important to understand that C# is a production language - i.e. one intended to be used to create real-world software. To support this goal, the developers of the C# language have made many efforts to make C# code easier to write, read, and reason about. Each new version of C# has added additional syntax and features to make the language more powerful and easier to use. In some cases, these are entirely new things the language couldn’t do previously, and in others they are syntactic sugar - a kind of abbreviation of an existing syntax.</description></item><item><title>The static Keyword</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/03-the-static-keyword/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/03-the-static-keyword/</guid><description>To start, let’s revisit one more keyword that causes a lot of confusion for new programmers, static. We mentioned it briefly when talking about encapsulation and modules, and said we could mimic a module in C# with a static class. We offered this example:
/// &lt;summary> /// A library of vector math functions /// &lt;/summary> public static class VectorMath { /// &lt;summary> /// Computes the dot product of two vectors /// &lt;/summary> public static double DotProduct(Vector3 a, Vector3 b) { return a.</description></item><item><title>Operator Overloading</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/04-operators/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/04-operators/</guid><description>C# allows you to override most of the language’s operators to provide class-specific functionality. The user-defined casts we discussed earlier are one example of this.
Perhaps the most obvious of these are the arithmetic operators, i.e. +, -, \, *. Consider our Vector3 class we defined earlier. If we wanted to overload the + operator to allow for vector addition, we could add it to the class definition:
/// &lt;summary> /// A class representing a 3-element vector /// &lt;/summary> public class Vector3 { /// &lt;summary>The x-coordinate&lt;/summary> public double X { get; set;} /// &lt;summary>The y-coordinate&lt;/summary> public double Y { get; set;} /// &lt;summary>The z-coordinate&lt;/summary> public double Z { get; set;} /// &lt;summary> /// Constructs a new vector /// &lt;/summary> public Vector3(double x, double y, double z) { X = x; Y = y; Z = z; } /// Adds two vectors using vector addition public static Vector3 operator +(Vector3 v1, Vector3 v2) { return new Vector3(v1.</description></item><item><title>Generics</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/05-generics/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/05-generics/</guid><description>Generics expand the type system of C# by allowing classes and structs to be defined with a generic type parameter, which will be instantiated when it is used in code. This avoids the necessity of writing similar specialized classes that each work with a different data type. You’ve used examples of this extensively in your CIS 300 - Data Structures course.
For example, the generic List&lt;T> can be used to create a list of any type.</description></item><item><title>Nullables</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/06-nullables/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/06-nullables/</guid><description>Returning to the distinction between value and reference types, a value type stores its value directly in the variable, while a reference type stores an address to another location in memory that has been allocated to hold the value. This is why reference types can be null - this indicates they aren’t pointing at anything. In contrast, value types cannot be null - they always contain a value. However, there are times it would be convenient to have a value type be allowed to be null.</description></item><item><title>Anonymous Types</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/07-anonymous-types/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/07-anonymous-types/</guid><description>Another new addition to C# is anonymous types. These are read-only objects whose type is created by the compiler rather than being defined in code. They are created using syntax very similar to object initializer syntax.
For example, the line:
var name = new { First="Jack", Last="Sprat" };Creates an anonymous object with properties First and Last and assigns it to the variable name. Note we have to use var, because the object does not have a defined type.</description></item><item><title>Lambda Syntax</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/08-lambda-syntax/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/08-lambda-syntax/</guid><description>The next topic we’ll cover is lambda syntax. You may remember from CIS 115 the Turing Machine, which was Alan Turing’s theoretical computer he used to prove a lot of theoretical computer science ideas. Another mathematician of the day, Alan Church, created his own equivalent of the Turing machine expressed as a formal logic system, Lambda calculus. Broadly speaking, the two approaches do the same thing, but are expressed very differently - the Turing machine is an (imaginary) hardware-based system, while Lambda Calculus is a formal symbolic system grounded in mathematical logic.</description></item><item><title>Pattern Matching</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/09-pattern-matching/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/09-pattern-matching/</guid><description>Pattern matching is another idea common to functional languages that has gradually crept into C#. Pattern matching refers to extracting information from structured data by matching the shape of that data.
We’ve already seen the pattern-matching is operator in our discussion of casting. This allows us to extract the cast version of a variable and assign it to a new one:
if(oldVariable is SpecificType newVariable) { // within this block newVariable is (SpecificType)oldVariable }The switch statement is also an example of pattern matching.</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/10-summary/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/06-advanced-csharp/10-summary/</guid><description>In this chapter we looked at some of the features of C# that aren’t directly related to object-orientation, including many drawn from imperative or functional paradigms. Some have been with the language since the beginning, such as the static keyword, while others have recently been added, like pattern matching.
Each addition has greatly expanded the power and usability of C# - consider generics, whose introduction brought entirely new (and much more performant) library collections like List&lt;T>, Dictionary&lt;T>, and HashSet&lt;T>.</description></item></channel></rss>