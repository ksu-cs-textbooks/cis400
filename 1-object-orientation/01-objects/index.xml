<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Classes and Objects :: K-State CIS 400 Textbook</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/</link><description>Getting Object Oriented</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 09 Dec 2024 10:06:29 -0600</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/01-introduction/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/01-introduction/</guid><description>A signature aspect of object-oriented languages is (as you might expect from the name), the existence of objects within the language. In this chapter, we take a deep look at objects, exploring why they were created, what they are at both a theoretical and practical level, and how they are used.
Key Terms Some key terms to learn in this chapter are:
Encapsulation
Information Hiding
Message Passing
State
Class
Object</description></item><item><title>Encapsulation</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/02-encapsulation/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/02-encapsulation/</guid><description>The first criteria that Alan Kay set for an object-oriented language was encapsulation. In computer science, the term encapsulation refers to organizing code into units. This provides a mechanism for organizing complex software.
A second related idea is information hiding, which provides mechanisms for controlling access to encapsulated data and how it can be changed.
Think back to the FORTRAN EPIC model we introduced earlier. All of the variables in that program were declared globally, and there were thousands.</description></item><item><title>C# Encapsulation Examples</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/03-csharp-encapsulation-examples/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/03-csharp-encapsulation-examples/</guid><description>Let’s start by focusing on encapsulation’s benefits to organizing our code by exploring some examples of encapsulation you may already be familiar with.
Namespaces The C# libraries are organized into discrete units called namespaces. The primary purpose of this is to separate code units that potentially use the same name, which causes name collisions where the interpreter isn’t sure which of the possibilities you mean in your program. This means you can use the same name to refer to two different things in your program, provided they are in different namespaces.</description></item><item><title>State and Behavior</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/04-state-and-behavior/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/04-state-and-behavior/</guid><description>The data stored in a program at any given moment (in the form of variables, objects, etc.) is the state of the program. Consider a variable:
int a = 5;The state of the variable a after this line is 5. If we then run:
a = a * 3;The state is now 15. Consider the Vector3 struct we defined in the last section:
public struct Vector3 { public double x; public double y; public double z; // constructor public Vector3(double x, double y, double z) { this.</description></item><item><title>Classes and Objects</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/05-classes-and-objects/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/05-classes-and-objects/</guid><description>The module-based encapsulation suggested by Parnas and his contemporaries grouped state and behavior together into smaller, self-contained units. Alan Kay and his co-developers took this concept a step farther. Alan Kay was heavily influenced by ideas from biology, and saw this encapsulation in similar terms to cells.
Biological cells are also encapsulated - the complex structures of the cell and the functions they perform are all within a cell wall. This wall is only bridged in carefully-controlled ways, i.</description></item><item><title>Information Hiding</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/06-information-hiding/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/06-information-hiding/</guid><description>Now let’s return to the concept of information hiding, and how it applies in object-oriented languages.
Unanticipated changes in state are a major source of errors in programs. Again, think back to the EPIC source code we looked at earlier. It may seem unusual now, but it used a common pattern from the early days of programming, where all the variables the program used were declared in one spot, and were global in scope (i.</description></item><item><title>C# Properties</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/07-csharp-properties/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/07-csharp-properties/</guid><description>While accessor methods provide a powerful control mechanism in object-oriented languages, they also require a lot of typing the same code syntax over and over (we often call this boilerplate). Many languages therefore introduce a mechanism for quickly defining basic accessors. In C#, we have Properties. Let’s rewrite our Student class with Properties:
public class Student { private string _first; /// &lt;summary>The student's first name&lt;/summary> public string First { get { return _first; } set { if(value.</description></item><item><title>Programs in Memory</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/08-program-memory/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/08-program-memory/</guid><description>YouTube Video Info The above video and below textbook content cover the same ideas (but are not identical). Feel free to pick one or the other.
Before we move on to our next concept, it is helpful to explore how programs use memory. Remember that modern computers are stored program computers, which means the program as well as the data are stored in the computer’s memory. A Universal Turing Machine, the standard example of a stored program computer, reads the program from the same paper tape that it reads its inputs to and writes its output to.</description></item><item><title>Objects in Memory</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/09-objects-in-memory/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/09-objects-in-memory/</guid><description>We often talk about the class as a blueprint for an object. This is because classes define what properties and methods an object should have, in the form of the class definition. An object is created from this blueprint by invoking the class’ constructor. Consider this class representing a planet:
/// &lt;summary> /// A class representing a planet // &lt;/summary> public class Planet { /// &lt;summary> /// The planet's mass in Earth Mass units (~5.</description></item><item><title>C# Object Initialization</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/10-csharp-initalization/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/10-csharp-initalization/</guid><description>With our broader understanding of objects in memory, let’s re-examine something you’ve been working with already, how the values in that memory are initialized (set to their initial values). In C#, there are four primary ways a value is initialized:
By zeroing the memory By setting a default value By the constructor With Initialization syntax This also happens to be the order in which these operations occur - i.e. the default value can be overridden by code in the constructor.</description></item><item><title>Message Passing</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/11-message-passing/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/11-message-passing/</guid><description>The second criterion Alan Kay set for object-oriented languages was message passing. Message passing is a way to request that a unit of code engage in a behavior, i.e. changing its state, or sharing some aspect of its state.
Consider the real-world analogue of a letter sent via the postal service. Such a message consists of: an address the message needs to be sent to, a return address, the message itself (the letter), and any data that needs to accompany the letter (the enclosures).</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/12-summary/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/01-objects/12-summary/</guid><description>In this chapter, we looked at how Object-Orientation adopted the concept of encapsulation to combine related state and behavior within a single unit of code, known as a class. We also discussed the three key features found in the implementation of classes and objects in Object-Oriented languages:
Encapsulation of state and behavior within an object, defined by its class Information hiding applied to variables defined within that class to prevent unwanted mutations of object state Message passing to allow controlled mutations of object state in well-defined ways We explored how objects are instances of a class created through invoking a constructor method, and how each object has its own independent state but shares behavior definitions with other objects constructed from the same class.</description></item></channel></rss>