<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.
Consider polymorphic functions in C# (aka Method Overloading, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:
int RoundedSum(int[] a) { int sum = 0; foreach(int i in a) { sum += i; } return sum; } int RoundedSum(float[] a) { double sum = 0; foreach(int i in a) { sum += i; } return (int)Math."><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Message Dispatching :: K-State CIS 400 Textbook"><meta name=twitter:description content="The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.
Consider polymorphic functions in C# (aka Method Overloading, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:
int RoundedSum(int[] a) { int sum = 0; foreach(int i in a) { sum += i; } return sum; } int RoundedSum(float[] a) { double sum = 0; foreach(int i in a) { sum += i; } return (int)Math."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/06-dispatch/embed.html"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Message Dispatching :: K-State CIS 400 Textbook"><meta property="og:description" content="The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.
Consider polymorphic functions in C# (aka Method Overloading, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:
int RoundedSum(int[] a) { int sum = 0; foreach(int i in a) { sum += i; } return sum; } int RoundedSum(float[] a) { double sum = 0; foreach(int i in a) { sum += i; } return (int)Math."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Object-Orientation"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-02-13T09:16:11-06:00"><meta itemprop=name content="Message Dispatching :: K-State CIS 400 Textbook"><meta itemprop=description content="The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.
Consider polymorphic functions in C# (aka Method Overloading, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:
int RoundedSum(int[] a) { int sum = 0; foreach(int i in a) { sum += i; } return sum; } int RoundedSum(float[] a) { double sum = 0; foreach(int i in a) { sum += i; } return (int)Math."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-02-13T09:16:11-06:00"><meta itemprop=wordCount content="935"><title>Message Dispatching :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/06-dispatch/ rel=canonical type=text/html title="Message Dispatching :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/02-polymorphism/06-dispatch/index.xml rel=alternate type=application/rss+xml title="Message Dispatching :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/02-polymorphism/06-dispatch/index.print.html rel=alternate type=text/html title="Message Dispatching :: K-State CIS 400 Textbook"><link href=/cis400/1-object-orientation/02-polymorphism/06-dispatch/tele.html rel=alternate type=text/html title="Message Dispatching :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1724766091 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1724766091 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1724766091 rel=stylesheet><link href=/cis400/css/auto-complete.css?1724766091 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1724766091 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1724766091 rel=stylesheet><link href=/cis400/css/fonts.css?1724766091 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1724766091 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1724766091 rel=stylesheet><link href=/cis400/css/theme-light-theme.css?1724766091 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-relearn-light.css?1724766091 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1724766091 rel=stylesheet><link href=/cis400/css/print.css?1724766091 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1724766091 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis400/1-object-orientation/02-polymorphism/06-dispatch/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><p>The term <em>dispatch</em> refers to how a language decides which polymorphic operation (a method or function) a message should trigger.</p><p>Consider polymorphic functions in C# (aka <em>Method Overloading</em>, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span> <span class=n>RoundedSum</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>foreach</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=k>in</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span> <span class=p>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>RoundedSum</span><span class=p>(</span><span class=kt>float</span><span class=p>[]</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=k>in</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=p>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Round</span><span class=p>(</span><span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>How does the interpreter know which version to invoke at runtime? It should not be a surprise that it is determined by the arguments - if an integer array is passed, the first is invoked, if a float array is passed, the second.</p><h2 id=object-oriented-polymorphism>Object-Oriented Polymorphism</h2><p>However, inheritance can cause some challenges in selecting the appropriate polymorphic form. Consider the following fruit implementations that feature a <strong>Blend()</strong> method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A base class representing fruit</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Fruit</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the fruit</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=s>&#34;A pulpy mess, I guess&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A class representing a banana</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Banana</span> <span class=p>:</span> <span class=n>Fruit</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the banana</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending the banana&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;yellow mush&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A class representing a Strawberry</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Strawberry</span> <span class=p>:</span> <span class=n>Fruit</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the strawberry</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending a strawberry&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Gooey Red Sweetness&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Let&rsquo;s add fruit instances to a list, and invoke their <code>Blend()</code> methods:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=n>Fruit</span><span class=p>&gt;</span> <span class=n>toBlend</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Fruit</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl><span class=n>toBlend</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=k>new</span> <span class=n>Banana</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>toBlend</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=k>new</span> <span class=n>Strawberry</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>foreach</span><span class=p>(</span><span class=n>Fruit</span> <span class=n>item</span> <span class=k>in</span> <span class=n>toBlend</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>item</span><span class=p>.</span><span class=n>Blend</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>You might expect this code to produce the lines:</p><div class=highlight><pre tabindex=0><code>yellow mush
Gooey Red Sweetness</code></pre></div><p>As these are the return values for the <code>Blend()</code> methods for the <code>Banana</code> and <code>Strawberry</code> classes, respectively. However, we will get:</p><div class=highlight><pre tabindex=0><code>A pulpy mess, I guess?
A pulpy mess, I guess?</code></pre></div><p>Which is the return value for the <code>Fruit</code> base class <code>Blend()</code> implementation. The line <code>forEach(Fruit item in toBlend)</code> explicitly tells the interpreter to treat the <code>item</code> as a <code>Fruit</code> instance, so of the two available methods (the base or super class implementation), the <code>Fruit</code> base class one is selected.</p><p>C# 4.0 introduced a new keyword, <a href=https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/using-type-dynamic rel=external target=_blank>dynamic</a> to allow variables like <code>item</code> to be dynamically typed at runtime. Hence, changing the loop to this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>forEach</span><span class=p>(</span><span class=kt>dynamic</span> <span class=n>item</span> <span class=k>in</span> <span class=n>toBlend</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>item</span><span class=p>.</span><span class=n>Blend</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Will give us the first set of results we discussed.</p><h2 id=method-overriding>Method Overriding</h2><p>Of course, part of the issue in the above example is that we actually have <em>two</em> implementations for <code>Blend()</code> available to each fruit. If we wanted all bananas to use the <code>Banana</code> class&rsquo;s <code>Blend()</code> method, even when the banana was being treated as a <code>Fruit</code>, we need to <em>override</em> the base method instead of creating a new one that hides it (in fact, in Visual Studio we should get a warning that our new method hides the base implementation, and be prompted to add the <code>new</code> keyword if that was our intent).</p><p>To override a base class method, we first must mark it as <code>abstract</code> or <code>virtual</code>. The first keyword, <code>abstract</code>, indicates that the method <em>does not have an implementation</em> (a body). The second, <code>virtual</code>, indicates that the base class <em>does</em> provide an implementation. We should use <code>abstract</code> when each derived class will define its own implementation, and <code>virtual</code> when some derived classes will want to use a common base implementation. Then, we must mark the method in the derived class with the <code>override</code> keyword.</p><p>Considering our <code>Fruit</code> class, since we&rsquo;re providing a unique implementation of <code>Blend()</code> in each derived class, the <code>abstract</code> keyword is more appropriate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A base class representing fruit</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>abstract</span> <span class=k>class</span> <span class=nc>Fruit</span> <span class=p>:</span> <span class=n>IBlendable</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the fruit</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>abstract</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>As you can see above, the <code>Blend()</code> method does not have a body, only the method signature.</p><p>Also, note that if we use an abstract method in a class, the class itself must <em>also</em> be declared abstract. The reason should be clear - an abstract method cannot be called, so we should not create an object that only has the abstract method. The virtual keyword can be used in both abstract and regular classes.</p><p>Now we can override the <code>Blend()</code> method in Banana class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A class representing a banana</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Banana</span> <span class=p>:</span> <span class=n>Fruit</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the banana</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending the banana&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>override</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;yellow mush&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now, even if we go back to our non-dynamic loop that treats our fruit as <code>Fruit</code> instances, we&rsquo;ll get the result of the <code>Banana</code> class&rsquo;s <code>Blend()</code> method.</p><p>We can override any method marked <code>abstract</code>, <code>virtual</code>, or <code>override</code> (this last will only occur in a derived class whose base class is also derived, as it is overriding an already-overridden method).</p><h2 id=sealed-methods>Sealed Methods</h2><p>We can also apply the <code>sealed</code> keyword to overridden methods, which prevents them from being overridden further. Let&rsquo;s apply this to the Strawberry class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A class representing a Strawberry</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Strawberry</span> <span class=p>:</span> <span class=n>Fruit</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Blends the strawberry</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;The result of blending a strawberry&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>sealed</span> <span class=kd>override</span> <span class=kt>string</span> <span class=n>Blend</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;Gooey Red Sweetness&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now, any class inheriting from Strawberry will not be allowed to override the Blend() method.</p><footer class=footline></footer></article></div></main></div><script src=/cis400/js/clipboard.min.js?1724766091 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1724766091 defer></script><script src=/cis400/js/theme.js?1724766091 defer></script><script src=/cis400/js/embed-iframe.js?1724766091 defer></script></body></html>