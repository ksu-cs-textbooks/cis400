<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Polymorphism :: K-State CIS 400 Textbook</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/</link><description>It’s a shapeshifter!</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 27 Jun 2024 14:36:54 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/01-introduction/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/01-introduction/</guid><description>The term polymorphism means many forms. In computer science, it refers to the ability of a single symbol (i.e. a function or class name) to represent multiple types. Some form of polymorphism can be found in nearly all programming languages.
While encapsulation of state and behavior into objects is the most central theoretical idea of object-oriented languages, polymorphism - specifically in the form of inheritance is a close second. In this chapter we’ll look at how polymorphism is commonly implemented in object-oriented languages.</description></item><item><title>Types</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/02-types/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/02-types/</guid><description>Before we can discuss polymorphism in detail, we must first understand the concept of types. In computer science, a type is a way of categorizing a variable by its storage strategy, i.e., how it is represented in the computer’s memory.
You’ve already used types extensively in your programming up to this point. Consider the declaration:
int number = 5;The variable number is declared to have the type int. This lets the .</description></item><item><title>Interfaces</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/03-interfaces/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/03-interfaces/</guid><description>If we think back to the concept of message passing in object-oriented languages, it can be useful to think of the collection of public methods available in a class as an interface, i.e., a list of messages you can dispatch to an object created from that class. When you were first learning a language (and probably even now), you find yourself referring to these kinds of lists, either in the language documentation, or via Intellisense in Visual Studio.</description></item><item><title>Object Inheritance</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/04-inheritance/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/04-inheritance/</guid><description>In an object-oriented language, inheritance is a mechanism for deriving part of a class definition from another existing class definition. This allows the programmer to “share” code between classes, reducing the amount of code that must be written.
Consider a Student class:
/// &lt;summary> /// A class representing a student /// &lt;/summary> public class Student { // private backing variables private double hours; private double points; /// &lt;summary> /// Gets the students' GPA /// &lt;/summary> public double GPA { get { return points / hours; } } /// &lt;summary> /// Gets or sets the first name /// &lt;/summary> public string First { get; set; } /// &lt;summary> /// Gets or sets the last name /// &lt;/summary> public string Last { get; set; } /// &lt;summary> /// Constructs a new instance of Student /// &lt;/summary> /// &lt;param name="first">The student's first name &lt;/param> /// &lt;param name="last">The student's last name&lt;/param> public Student(string first, string last) { this.</description></item><item><title>Casting</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/05-casting/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/05-casting/</guid><description>You have probably used casting to convert numeric values from one type to another, i.e.:
int a = 5; double b = a;And
int c = (int)b;What you are actually doing when you cast is transforming a value from one type to another. In the first case, you are taking the value of a (5), and converting it to the equivalent double (5.0). If you consider the internal representation of an integer (a 2’s complement binary number) to a double (an IEEE 754 standard representation), we are actually applying a conversion algorithm to the binary representations.</description></item><item><title>Message Dispatching</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/06-dispatch/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/06-dispatch/</guid><description>The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.
Consider polymorphic functions in C# (aka Method Overloading, where multiple methods use the same name but have different parameters) like this one for calculating the rounded sum of an array of numbers:
int RoundedSum(int[] a) { int sum = 0; foreach(int i in a) { sum += i; } return sum; } int RoundedSum(float[] a) { double sum = 0; foreach(int i in a) { sum += i; } return (int)Math.</description></item><item><title>C# Collections</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/07-csharp-collections/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/07-csharp-collections/</guid><description>Collections in C# are a great example of polymorphism in action. Many collections utilize generics to allow the collection to hold an arbitrary type. For example, the List&lt;T> can be used to hold strings, integers, or even specific objects:
List&lt;string> strings = new List&lt;string>(); List&lt;int> ints = new List&lt;int>(); List&lt;Person> persons = new List&lt;Person>();We can also use an interface as the type, as we did with the IJumpable interface as we discussed in the generics section, i.</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/08-summary/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/1-object-orientation/02-polymorphism/08-summary/</guid><description>In this chapter, we explored the concept of types and discussed how variables are specific types that can be explicitly or implicitly declared. We saw how in a statically-typed language (like C#), variables are not allowed to change types (though they can do so in a dynamically-typed language). We also discussed how casting can convert a value stored in a variable into a different type. Implicit casts can happen automatically, but explicit casts must be indicated by the programmer using a cast operator, as the cast could result in loss of precision or the throwing of an exception.</description></item></channel></rss>