<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: Model-View-ViewModel. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view."><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="MVVM Architecture :: K-State CIS 400 Textbook"><meta name=twitter:description content="You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: Model-View-ViewModel. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/05-mvvm/embed.html"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="MVVM Architecture :: K-State CIS 400 Textbook"><meta property="og:description" content="You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: Model-View-ViewModel. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Desktop Development"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-03-19T11:45:37-05:00"><meta itemprop=name content="MVVM Architecture :: K-State CIS 400 Textbook"><meta itemprop=description content="You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: Model-View-ViewModel. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-03-19T11:45:37-05:00"><meta itemprop=wordCount content="188"><title>MVVM Architecture :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/05-mvvm/ rel=canonical type=text/html title="MVVM Architecture :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/05-mvvm/index.xml rel=alternate type=application/rss+xml title="MVVM Architecture :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/05-mvvm/index.print.html rel=alternate type=text/html title="MVVM Architecture :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/05-mvvm/tele.html rel=alternate type=text/html title="MVVM Architecture :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1724766093 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1724766093 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1724766093 rel=stylesheet><link href=/cis400/css/auto-complete.css?1724766093 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1724766093 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1724766093 rel=stylesheet><link href=/cis400/css/fonts.css?1724766093 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1724766093 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1724766093 rel=stylesheet><link href=/cis400/css/theme-light-theme.css?1724766093 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-relearn-light.css?1724766093 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1724766093 rel=stylesheet><link href=/cis400/css/print.css?1724766093 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1724766093 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis400/2-desktop-development/05-dependency-objects/05-mvvm/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><p>You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: <a href=https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel rel=external target=_blank>Model-View-ViewModel</a>. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view.</p><p><a href=#R-image-f1a931bf0bf32116dc0f918267fe7e16 class=lightbox-link><img alt="MVVM Pattern" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/MVVMPattern.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f1a931bf0bf32116dc0f918267fe7e16><img alt="MVVM Pattern" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/MVVMPattern.png></a></p><p>There are several benefits to this pattern:</p><ol><li>Complex logic is kept out of the View classes, allowing them to focus on the task of presentation</li><li>Presentation logic is kept out of the Model classes, allowing them to focus on the task of data management and allowing them to be easily re-used for other views</li><li>Presentation logic is gathered in the ViewModel class, where it can be easily tested</li></ol><p>Essentially, this pattern is an application of the <a href=https://en.wikipedia.org/wiki/Single-responsibility_principle rel=external target=_blank>Single-Responsibility Principle</a> (that each class in your project should bear a single responsibility).</p><footer class=footline></footer></article></div></main></div><script src=/cis400/js/clipboard.min.js?1724766093 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1724766093 defer></script><script src=/cis400/js/theme.js?1724766093 defer></script><script src=/cis400/js/embed-iframe.js?1724766093 defer></script></body></html>