<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dependency Objects :: K-State CIS 400 Textbook</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/</link><description>The Bedrock of WPF</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 27 Jun 2024 14:36:54 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/01-introduction/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/01-introduction/</guid><description>You’ve now worked with a variety of WPF controls, laid out components using containers, traversed the elements tree, performed data binding,and worked with routed events. Each of these is made possible through the use of several classes: DependencyObject, UIElement, and FrameworkElement, which serve as a base classes for all WPF controls. In this chapter we’ll dig deeper into how these base classes implement dependency properties and routed events.
Key Terms Some key terms to learn in this chapter are:</description></item><item><title>Dependency Properties</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/02-dependency-properties/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/02-dependency-properties/</guid><description>Perhaps the most important aspect of the DependencyObject is its support for hosting dependency properties. While these appear and can be used much like the C# properties we have previously worked with, internally they are managed very differently. Consider when we place a &lt;TextBox> in a &lt;Grid>:
&lt;Grid> &lt;Grid.ColumnDefinitions> &lt;ColumnDefinition/> &lt;ColumnDefinition/> &lt;/Grid.ColumnDefinitions> &lt;Grid.RowDefinitions> &lt;RowDefinition/> &lt;RowDefinition/> &lt;/Grid.RowDefinitions> &lt;TextBox Name="textBox" Grid.Column="1" Grid.Row="1"/> &lt;/Grid>Where do the Column and Row properties come from? They aren’t defined on the TextBox class - you can check the documentation.</description></item><item><title>Framework Elements</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/03-framework-elements/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/03-framework-elements/</guid><description>WPF controls are built on the foundation of dependency objects - the DependencyObject is at the bottom of their inheritance chain. But they also add additional functionality on top of that through another common base class, FrameworkElement. The FrameworkElement is involved in the layout algorithm, as well as helping to define the elements tree. Let’s add a second dependency property to our &lt;NumberBox>, a Value property that will represent the value the &lt;NumberBox> currently represents, which will be displayed in the &lt;TextBox>.</description></item><item><title>Routed Events</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/04-routed-events/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/04-routed-events/</guid><description>Another aspect of WPF elements are routed events. Just as dependency properties are similar to regular C# properties, but add additional functionality, routed events are similar to regular C# events, but provide additional functionality. One of the most important of these is the ability of the routed event to “bubble” up the elements tree. Essentially, the event will be passed up each successive WPF element until one chooses to “handle” it, or the top of the tree is reached (in which case the event is ignored).</description></item><item><title>MVVM Architecture</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/05-mvvm/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/05-mvvm/</guid><description>You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: Model-View-ViewModel. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view.</description></item><item><title>Summary</title><link>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/06-summary/</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/06-summary/</guid><description>In this chapter we examined how dependency properties and routed events are implemented in WPF. The DependencyObject, which serves as a base class for WPF elements, provides a collection of key/value pairs, where the key is a DependencyProperty and the value is the object it is set to. This collection can be accessed through the GetValue() and SetValue() methods, and is also used as a backing store for regular C# properties.</description></item></channel></rss>