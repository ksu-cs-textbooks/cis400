<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="The Bedrock of WPF"><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dependency Objects :: K-State CIS 400 Textbook"><meta name=twitter:description content="The Bedrock of WPF"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Dependency Objects :: K-State CIS 400 Textbook"><meta property="og:description" content="The Bedrock of WPF"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Dependency Objects :: K-State CIS 400 Textbook"><meta itemprop=description content="The Bedrock of WPF"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:29:34-05:00"><meta itemprop=wordCount content="4"><title>Dependency Objects :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/05-dependency-objects/ rel=canonical type=text/html title="Dependency Objects :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/index.xml rel=alternate type=application/rss+xml title="Dependency Objects :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/tele.html rel=alternate type=text/html title="Dependency Objects :: K-State CIS 400 Textbook"><link href=/cis400/2-desktop-development/05-dependency-objects/embed.html rel=alternate type=text/html title="Dependency Objects :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1737134602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1737134602 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1737134602 rel=stylesheet><link href=/cis400/css/auto-complete.css?1737134602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1737134602 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1737134602 rel=stylesheet><link href=/cis400/css/fonts.css?1737134602 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1737134602 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1737134602 rel=stylesheet><link href=/cis400/css/theme-auto.css?1737134602 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-auto.css?1737134602 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1737134602 rel=stylesheet><link href=/cis400/css/print.css?1737134602 rel=stylesheet media=print><link href=/cis400/css/format-print.css?1737134602 rel=stylesheet><script src=/cis400/js/variant.js?1737134602></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1737134602 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis400/2-desktop-development/05-dependency-objects/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis400/2-desktop-development/><span itemprop=name>Desktop Development</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Dependency Objects</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/2-desktop-development/04-data-binding/06-summary/ title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/2-desktop-development/05-dependency-objects/01-introduction/ title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 5</div><h1 id=dependency-objects>Dependency Objects</h1><p>The Bedrock of WPF</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Dependency Objects</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>You&rsquo;ve now worked with a variety of WPF controls, laid out components using containers, traversed the elements tree, performed data binding,and worked with routed events. Each of these is made possible through the use of several classes: <code>DependencyObject</code>, <code>UIElement</code>, and <code>FrameworkElement</code>, which serve as a base classes for all WPF controls. In this chapter we&rsquo;ll dig deeper into how these base classes implement <em>dependency properties</em> and <em>routed events</em>.</p><h2 id=key-terms>Key Terms</h2><p>Some key terms to learn in this chapter are:</p><ul><li>Dependency Property</li><li>Routed Event</li><li>MVVM Pattern</li></ul><h2 id=key-skills>Key Skills</h2><p>Some key skills you need to develop in this chapter are:</p><ul><li>Creating custom dependency properties</li><li>Handling routed events</li><li>Creating custom routed events</li><li>Using dependency property callbacks</li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=dependency-properties>Dependency Properties</h1><p>Perhaps the most important aspect of the <code>DependencyObject</code> is its support for hosting <em>dependency properties</em>. While these appear and can be used much like the C# properties we have previously worked with, internally they are managed very differently. Consider when we place a <code>&lt;TextBox></code> in a <code>&lt;Grid></code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;Grid&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Grid.RowDefinitions&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;RowDefinition/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;RowDefinition/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/Grid.RowDefinitions&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;TextBox</span> <span class=na>Name=</span><span class=s>&#34;textBox&#34;</span> <span class=na>Grid.Column=</span><span class=s>&#34;1&#34;</span> <span class=na>Grid.Row=</span><span class=s>&#34;1&#34;</span><span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/Grid&gt;</span></span></span></code></pre></div><p>Where do the <code>Column</code> and <code>Row</code> properties come from? They aren&rsquo;t defined on the <code>TextBox</code> class - you can <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.controls.textbox?view=netcore-3.1#properties" rel=external target=_blank>check the documentation</a>. The answer is they are made available through the dependency property system.</p><p>At the heart of this system is a collection of key/value pairs much like the <code>Dictionary</code>. When the XAML code <code>Grid.Column="1"</code> is processed, this key and value are added to the <code>TextBox</code>&rsquo;s dependency properties collection, and is thereafter accessible by the WPF rendering algorithm.</p><p>The <code>DependencyObject</code> exposes these stored values with the <code>GetValue(DependencyProperty)</code> and <code>SetValue(DependencyProperty, value)</code> methods. For example, we can set the <code>Column</code> property to <code>2</code> with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>textBox</span><span class=p>.</span><span class=n>SetValue</span><span class=p>(</span><span class=n>Grid</span><span class=p>.</span><span class=n>ColumnProperty</span><span class=p>,</span> <span class=m>2</span><span class=p>);</span></span></span></code></pre></div><p>We can also create <em>new</em> dependency properties on our own custom classes extending the <code>DependencyObject</code> (which is also a base class for all WPF controls). Let&rsquo;s say we are making a custom control for entering number values on a touch screen, which we&rsquo;ll call <code>NumberBox</code>. We can extend a <code>UserControl</code> to create a textbox centered between two buttons, one to increase the value, and one to decrease it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;UserControl</span> <span class=na>x:Class=</span><span class=s>&#34;CustomDependencyObjectExample.NumberBox&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns=</span><span class=s>&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:x=</span><span class=s>&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:mc=</span><span class=s>&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&#34;</span> 
</span></span><span class=line><span class=cl>             <span class=na>xmlns:d=</span><span class=s>&#34;http://schemas.microsoft.com/expression/blend/2008&#34;</span> 
</span></span><span class=line><span class=cl>             <span class=na>xmlns:local=</span><span class=s>&#34;clr-namespace:CustomDependencyObjectExample&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>mc:Ignorable=</span><span class=s>&#34;d&#34;</span> 
</span></span><span class=line><span class=cl>             <span class=na>d:DesignHeight=</span><span class=s>&#34;50&#34;</span> <span class=na>d:DesignWidth=</span><span class=s>&#34;200&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Grid&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition</span> <span class=na>Width=</span><span class=s>&#34;2*&#34;</span><span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;/Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Button</span> <span class=na>Grid.Column=</span><span class=s>&#34;0&#34;</span><span class=nt>&gt;</span>+<span class=nt>&lt;/Button&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;TextBox</span> <span class=na>Grid.Column=</span><span class=s>&#34;1&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Button</span> <span class=na>Grid.Column=</span><span class=s>&#34;2&#34;</span><span class=nt>&gt;</span>-<span class=nt>&lt;/Button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/Grid&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/UserControl&gt;</span></span></span></code></pre></div><p>Now, let&rsquo;s assume we want to provide a property <code>Step</code> of type <code>double</code>, which is the amount the number should be incremented when the &ldquo;+&rdquo; or &ldquo;-&rdquo; button is pressed.</p><p>The first step is to <em>register</em> the dependency property by creating a <code>DependencyProperty</code> instance. This will serve as the key to setting and retrieving the dependency property on a dependency object. We register new dependency properties with <code>DependencyProperty.Register(string propertyName, Type propertyType, Type dependencyObjectType)</code>. The string is the name of the property, the first type is the type of the property, and the second is the class we want to associate this property with. So our <code>Step</code> property would be registered with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>DependencyProperty</span><span class=p>.</span><span class=n>Register</span><span class=p>(</span><span class=n>nameof</span><span class=p>(</span><span class=n>Step</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=kt>double</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>));</span></span></span></code></pre></div><p>There is an optional fourth property to <code>DependencyProperty.Register()</code> which is a <code>PropertyMetadata</code>. This is used to set the default value of the property. We probably should specify a default step, so let&rsquo;s add a <code>PropertyMetadata</code> object with a default value of 1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>DependencyProperty</span><span class=p>.</span><span class=n>Register</span><span class=p>(</span><span class=n>nameof</span><span class=p>(</span><span class=n>Step</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=kt>double</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>),</span> <span class=k>new</span> <span class=n>PropertyMetadata</span><span class=p>(</span><span class=m>1.0</span><span class=p>));</span></span></span></code></pre></div><p>The <code>DependencyProperty.Register()</code> method returns a registered <code>DependencyObject</code> to serve as a key for accessing our new property. To make sure we can access this key from <em>other</em> classes, we define it as a field that is <code>public</code>, <code>static</code>, and <code>readonly</code>. The naming convention for <code>DependencyProperties</code> is to name this field by appending &ldquo;Property&rdquo; to the name of the property.</p><p>Thus, the complete registration, including saving the result to the public static field is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Identifies the NumberBox.Step XAML attached property</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=k>readonly</span> <span class=n>DependencyProperty</span> <span class=n>StepProperty</span> <span class=p>=</span> <span class=n>DependencyProperty</span><span class=p>.</span><span class=n>Register</span><span class=p>(</span><span class=n>nameof</span><span class=p>(</span><span class=n>Step</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=kt>double</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>),</span> <span class=k>new</span> <span class=n>PropertyMetadata</span><span class=p>(</span><span class=m>1.0</span><span class=p>));</span> </span></span></code></pre></div><p>We also want to declare a traditional property with the name &ldquo;Step&rdquo;. But instead of declaring a backing field, we will use the key/value pair stored in our <code>DependencyObject</code> using <code>GetValue()</code> and <code>SetValue()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The amount each increment or decrement operation should change the value by</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>double</span> <span class=n>Step</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>GetValue</span><span class=p>(</span><span class=n>StepProperty</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>set</span> <span class=p>{</span> <span class=n>SetValue</span><span class=p>(</span><span class=n>StepProperty</span><span class=p>,</span> <span class=k>value</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>As dependency property values are stored as an <code>object</code>, we need to cast the value to a the appropriate type when it is returned.</p><p>One of the great benefits of dependency properties is that they can be set using XAML. I.e. we could declare an instance of our <code>&lt;NumberBox></code> and set its <code>Step</code> using an attribute:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;StackPanel&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;NumberBox</span> <span class=na>Step=</span><span class=s>&#34;3.0&#34;</span><span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/StackPanel&gt;</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=framework-elements>Framework Elements</h1><p>WPF controls are built on the foundation of dependency objects - the <code>DependencyObject</code> is at the bottom of their inheritance chain. But they also add additional functionality on top of that through another common base class, <code>FrameworkElement</code>. The <code>FrameworkElement</code> is involved in the layout algorithm, as well as helping to define the <a href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/02-element-tree/ rel=external target=_blank>elements tree</a>. Let&rsquo;s add a <em>second</em> dependency property to our <code>&lt;NumberBox></code>, a <code>Value</code> property that will represent the value the <code>&lt;NumberBox></code> currently represents, which will be displayed in the <code>&lt;TextBox></code>.</p><p>We register this dependency property in much the same way as our <code>Step</code>. But instead of supplying the <code>DependencyProperty.Register()</code> method a <code>PropertyMetadata</code>, we&rsquo;ll instead supply a <code>FrameworkPropertyMetadata</code>, which extends <code>PropertyMetadata</code> to include additional data about how the property interacts with the WPF rendering and layout algorithms. This additional data is in the form of a bitmask defined in <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.frameworkpropertymetadataoptions?view=netcore-3.1" rel=external target=_blank>FrameworkPropertyMetadataOptions</a> enumeration.</p><p>Some of the possible options are:</p><ul><li><code>FrameworkPropertyMetadataOptions.AffectsMeasure</code> - changes to the property may affect the size of the control</li><li><code>FrameworkPropertyMetadataOptions.AffectsArrange</code> - changes to the property may affect the layout of the control</li><li><code>FrameworkPropertyMetadataOptions.AffectsRender</code> - changes to the property may affect the appearance of the control</li><li><code>FrameworkPropertyMetadataOptions.BindsTwoWayByDefault</code> - This property uses two-way bindings by default (i.e. the control is an editable control)</li><li><code>FrameworkPropertyMetadataOptions.NotDataBindable</code> - This property does not allow data binding</li></ul><p>In this case, we want a two-way binding by default, so we&rsquo;ll include that flag, and also we&rsquo;ll note that it affects the rendering process. Multiple flags can be combined with a <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-or-operator- rel=external target=_blank>bitwise OR</a>. Constructing our <code>FrameworkPropertyMetadata</code> object would then look like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>new</span> <span class=n>FrameworkPropertyMetadata</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>AffectsRender</span> <span class=p>|</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>BindsTwoWayByDefault</span><span class=p>)</span></span></span></code></pre></div><p>And registering the dependency property would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Identifies the NumberBox.Value XAML attached property</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=k>readonly</span> <span class=n>DependencyProperty</span> <span class=n>ValueProperty</span> <span class=p>=</span> <span class=n>DependencyProperty</span><span class=p>.</span><span class=n>Register</span><span class=p>(</span><span class=n>nameof</span><span class=p>(</span><span class=n>Value</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=kt>double</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>),</span> <span class=k>new</span> <span class=n>FrameworkPropertyMetadata</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>AffectsRender</span> <span class=p>|</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>BindsTwoWayByDefault</span><span class=p>));</span></span></span></code></pre></div><p>As with the <code>Step</code>, we also want to declare a traditional property with the name &ldquo;Value&rdquo;. But instead of declaring a backing field, we will use the key/value pair stored in our <code>DependencyObject</code> using <code>GetValue()</code> and <code>SetValue()</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The NumberBox&#39;s displayed value</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>double</span> <span class=n>Value</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>GetValue</span><span class=p>(</span><span class=n>ValueProperty</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>set</span> <span class=p>{</span> <span class=n>SetValue</span><span class=p>(</span><span class=n>ValueProperty</span><span class=p>,</span> <span class=k>value</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If we want to display the current value of <code>Value</code> in the textbox of our <code>NumberBox</code> control, we&rsquo;ll need to bind the <code>&lt;TextBox></code> element&rsquo;s <code>Text</code> property. This is accomplished in a similar fashion to the other bindings we&rsquo;ve done previously, only we need to specify a <code>RelativeSource</code>. This is a source relative to the control in the <a href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/02-element-tree/ rel=external target=_blank>elements tree</a>. We&rsquo;ll specify two properties on the <code>RelativeSource</code>: the <code>Mode</code> which we set to <code>FindAncestor</code> to search up the tree, and the <code>AncestorType</code> which we set to our <code>NumberBox</code>. Thus, instead of binding to the <code>DataContext</code>, we&rsquo;ll bind to the <code>NumberBox</code> the <code>&lt;TextBox></code> is located within. The full declaration would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;TextBox</span> <span class=na>Grid.Column=</span><span class=s>&#34;1&#34;</span> <span class=na>Text=</span><span class=s>&#34;{Binding Path=Value, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType=local:NumberBox}}&#34;</span><span class=nt>/&gt;</span></span></span></code></pre></div><p>Now a two-way binding exists between the <code>Value</code> of the <code>&lt;NumberBox></code> and the <code>Text</code> value of the textbox. Updating either one will update the other. We&rsquo;ve in effect made an editable control!</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=routed-events>Routed Events</h1><p>Another aspect of WPF elements are <em>routed events</em>. Just as <em>dependency properties</em> are similar to regular C# properties, but add additional functionality, <em>routed events</em> are similar to regular C# events, but provide additional functionality. One of the most important of these is the ability of the routed event to &ldquo;bubble&rdquo; up the <a href=https://textbooks.cs.ksu.edu/cis400/2-desktop-development/02-element-tree/ rel=external target=_blank>elements tree</a>. Essentially, the event will be passed up each successive WPF element until one chooses to &ldquo;handle&rdquo; it, or the top of the tree is reached (in which case the event is ignored). This routed event functionality is managed by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.uielement?view=netcore-3.1" rel=external target=_blank><code>UIElement</code></a> base class, a third base class shared by all WPF elements.</p><p>Let&rsquo;s consider the two buttons we declared in our <code>&lt;NumberBox></code>. When clicked, these each trigger a <code>Click</code> routed event. We could attach a handler to each button, but it is also possible to instead attach it to any other element up the tree; for example, our <code>&lt;Grid></code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;UserControl</span> <span class=na>x:Class=</span><span class=s>&#34;CustomDependencyObjectExample.NumberBox&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns=</span><span class=s>&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:x=</span><span class=s>&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:mc=</span><span class=s>&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:d=</span><span class=s>&#34;http://schemas.microsoft.com/expression/blend/2008&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>xmlns:local=</span><span class=s>&#34;clr-namespace:CustomDependencyObjectExample&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>mc:Ignorable=</span><span class=s>&#34;d&#34;</span>
</span></span><span class=line><span class=cl>             <span class=na>d:DesignHeight=</span><span class=s>&#34;50&#34;</span> <span class=na>d:DesignWidth=</span><span class=s>&#34;200&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Grid</span> <span class=na>Button.Click=</span><span class=s>&#34;HandleButtonClick&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition</span> <span class=na>Width=</span><span class=s>&#34;2*&#34;</span><span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>            <span class=nt>&lt;ColumnDefinition/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;/Grid.ColumnDefinitions&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Button</span> <span class=na>Grid.Column=</span><span class=s>&#34;0&#34;</span> <span class=na>Name=</span><span class=s>&#34;Increment&#34;</span><span class=nt>&gt;</span>+<span class=nt>&lt;/Button&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;TextBox</span> <span class=na>Grid.Column=</span><span class=s>&#34;1&#34;</span> <span class=na>Text=</span><span class=s>&#34;{Binding Path=Value, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType=local:NumberBox}}&#34;</span><span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;Button</span> <span class=na>Grid.Column=</span><span class=s>&#34;2&#34;</span> <span class=na>Name=</span><span class=s>&#34;Decrement&#34;</span><span class=nt>&gt;</span>-<span class=nt>&lt;/Button&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/Grid&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/UserControl&gt;</span></span></span></code></pre></div><p>We&rsquo;d need to define <code>HandleButtonClick</code> in our codebehind:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles the click of the increment or decrement button</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The button clicked&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;The event arguments&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=k>void</span> <span class=n>HandleButtonClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>RoutedEventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>sender</span> <span class=k>is</span> <span class=n>Button</span> <span class=n>button</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>button</span><span class=p>.</span><span class=n>Name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;Increment&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>Value</span> <span class=p>+=</span> <span class=n>Step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=s>&#34;Decrement&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>Value</span> <span class=p>-=</span> <span class=n>Step</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>Handled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>When either button is clicked, it creates a <code>Button.Click</code> event. As the buttons don&rsquo;t handle it, the event bubbles to the next element in the elements tree - in this case, the <code>&lt;Grid></code>. As the <code>&lt;Grid></code> <em>does</em> attach a <code>Button.Click</code> listener, the event is passed to <code>HandleButtonClick</code>. In this method we use the button&rsquo;s <code>Name</code> property to decide the correct action to take. Also, note that we set the <code>RoutedEventArgs.Handled</code> property to <code>true</code>. This lets WPF know that we&rsquo;ve taken care of the event, and it does not need to bubble up any farther (if we didn&rsquo;t, we could process the event <em>again</em> further up the elements tree).</p><p>Much like dependency properties, we can declare our own routed events. These also use a <code>Register()</code> method, but for events this is a static method of the <code>EventHandler</code> class: <code>EventManager.Register(string eventName, RoutingStrategy routing, Type eventHandlerType, Type controlType)</code>. The first argument is a string, which is the name of the event, the second is one of the values from the <code>RoutingStrategy</code> enum, the third is the type of event handler, and the fourth is the type of the control it is declared in. This <code>Register()</code> method returns a <code>RoutedEvent</code> that is used as a key when registering event listeners, which we typically store in a <code>public static readonly RoutedEvent</code> field.</p><p>The <code>RoutingStrategy</code> options are</p><ul><li><code>RoutingStrategy.Bubble</code> - which travels up the elements tree through ancestor nodes</li><li><code>RoutingStrategy.Tunnel</code> - which travels down the elements tree through descendant nodes</li><li><code>RoutingStrategy.Direct</code> - which can only be handled by the source element</li></ul><p>Let&rsquo;s create an example routed event for our <code>NumberBox</code>. Let&rsquo;s assume we define two more routed properties <code>MinValue</code> and <code>MaxValue</code>, and that any time we change the value of our <code>NumberBox</code> it must fall within this range, or be clamped to one of those values. To make it easer for UI designers to provide user feedback, we&rsquo;ll create a <code>NumberBox.ValueClamped</code> event that will trigger in these circumstances. We need to register our new routed event:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Identifies the NumberBox.ValueClamped event</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=k>readonly</span> <span class=n>RoutedEvent</span> <span class=n>ValueClampedEvent</span> <span class=p>=</span> <span class=n>EventManager</span><span class=p>.</span><span class=n>RegisterRoutedEvent</span><span class=p>(</span><span class=n>nameof</span><span class=p>(</span><span class=n>ValueClamped</span><span class=p>),</span> <span class=n>RoutingStrategy</span><span class=p>.</span><span class=n>Bubble</span><span class=p>,</span> <span class=k>typeof</span><span class=p>(</span><span class=n>RoutedEventHandler</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>));</span></span></span></code></pre></div><p>Also like dependency properties also need to declare a corresponding C# property, routed events need to declare a corresponding C# event:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Event that is triggered when the value of this NumberBox changes</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>event</span> <span class=n>RoutedEventHandler</span> <span class=n>ValueClamped</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>add</span> <span class=p>{</span> <span class=n>AddHandler</span><span class=p>(</span><span class=n>ValueClampedEvent</span><span class=p>,</span> <span class=k>value</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>remove</span> <span class=p>{</span> <span class=n>RemoveHandler</span><span class=p>(</span><span class=n>ValueClampedEvent</span><span class=p>,</span> <span class=k>value</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Finally, we would want to raise this event whenever the value is clamped. This can be done with the <code>RaiseEvent(RoutedEventArgs)</code> method defined on the <code>UIElement</code> base class that we inherit in our custom controls. But where should we place this call?</p><p>You might think we would do this in the <code>HandleButtonClick()</code> method, and we could, but that misses when a user types a number <em>directly into the textbox</em>, as well as when <code>Value</code> is updated through a two-way binding. Instead, we&rsquo;ll utilize the callback functionality available in the <code>FrameworkPropertyMetadata</code> for the <code>Value</code> property. Since the dependency property and its metadata are both <code>static</code>, our callback also needs to be declared <code>static</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Callback for the ValueProperty, which clamps the Value to the range</span>
</span></span><span class=line><span class=cl><span class=cs>/// defined by MinValue and MaxValue</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The NumberBox whose value is changing&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;The event args&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>static</span> <span class=k>void</span> <span class=n>HandleValueChanged</span><span class=p>(</span><span class=n>DependencyObject</span> <span class=n>sender</span><span class=p>,</span> <span class=n>DependencyPropertyChangedEventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>Property</span><span class=p>.</span><span class=n>Name</span> <span class=p>==</span> <span class=s>&#34;Value&#34;</span> <span class=p>&amp;&amp;</span> <span class=n>sender</span> <span class=k>is</span> <span class=n>NumberBox</span> <span class=n>box</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>box</span><span class=p>.</span><span class=n>Value</span> <span class=p>&lt;</span> <span class=n>box</span><span class=p>.</span><span class=n>MinValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>box</span><span class=p>.</span><span class=n>Value</span> <span class=p>=</span> <span class=n>box</span><span class=p>.</span><span class=n>MinValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>box</span><span class=p>.</span><span class=n>RaiseEvent</span><span class=p>(</span><span class=k>new</span> <span class=n>RoutedEventArgs</span><span class=p>(</span><span class=n>ValueClampedEvent</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>box</span><span class=p>.</span><span class=n>Value</span> <span class=p>&gt;</span> <span class=n>box</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>box</span><span class=p>.</span><span class=n>Value</span> <span class=p>=</span> <span class=n>box</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>box</span><span class=p>.</span><span class=n>RaiseEvent</span><span class=p>(</span><span class=k>new</span> <span class=n>RoutedEventArgs</span><span class=p>(</span><span class=n>ValueClampedEvent</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that since this method is static, we must get the instance of the <code>NumberBox</code> by casting the <code>sender</code>. We also double-check the property name, though this is not strictly necessary as the method is private and only we should be invoking it from within this class.</p><p>Now we need to refactor our <code>Value</code> dependency property registration to use this callback:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Identifies the NumberBox.Value XAML attached property</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=k>readonly</span> <span class=n>DependencyProperty</span> <span class=n>ValueProperty</span> <span class=p>=</span> <span class=n>DependencyProperty</span><span class=p>.</span><span class=n>Register</span><span class=p>(</span><span class=s>&#34;Value&#34;</span><span class=p>,</span> <span class=k>typeof</span><span class=p>(</span><span class=kt>double</span><span class=p>),</span> <span class=k>typeof</span><span class=p>(</span><span class=n>NumberBox</span><span class=p>),</span> <span class=k>new</span> <span class=n>FrameworkPropertyMetadata</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>AffectsRender</span> <span class=p>|</span> <span class=n>FrameworkPropertyMetadataOptions</span><span class=p>.</span><span class=n>BindsTwoWayByDefault</span><span class=p>,</span> <span class=n>HandleValueChanged</span><span class=p>));</span></span></span></code></pre></div><p>By adding the callback to the dependency property, we ensure that <em>any time it changes</em>, regardless of the method the change occurs by, we will ensure the value is clamped to the specified range.</p><p>There are additional options for dependency property callbacks, including validation callbacks and the ability to coerce values. See <a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/dependency-property-callbacks-and-validation?view=netframeworkdesktop-4.8" rel=external target=_blank>the documentation</a> for details.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=mvvm-architecture>MVVM Architecture</h1><p>You have probably noticed that as our use of WPF grows more sophisticated, our controls start getting large, and often filled with complex logic. You are not alone in noticing this trend. Microsoft architects Ken Cooper and Ted Peters also struggled with the idea, and introduced a new software architectural pattern to help alleviate it: <a href=https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel rel=external target=_blank>Model-View-ViewModel</a>. This approach splits the user interface code into two classes: the View (the XAML + codebehind), and a ViewModel, which applies any logic needed to format the data from the model object into a form more easily bound and consumed by the view.</p><p><a href=#R-image-c9353e2faa5c7aed0d8adb4d5fb03fad class=lightbox-link><img alt="MVVM Pattern" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/MVVMPattern.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c9353e2faa5c7aed0d8adb4d5fb03fad><img alt="MVVM Pattern" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/MVVMPattern.png></a></p><p>There are several benefits to this pattern:</p><ol><li>Complex logic is kept out of the View classes, allowing them to focus on the task of presentation</li><li>Presentation logic is kept out of the Model classes, allowing them to focus on the task of data management and allowing them to be easily re-used for other views</li><li>Presentation logic is gathered in the ViewModel class, where it can be easily tested</li></ol><p>Essentially, this pattern is an application of the <a href=https://en.wikipedia.org/wiki/Single-responsibility_principle rel=external target=_blank>Single-Responsibility Principle</a> (that each class in your project should bear a single responsibility).</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=summary>Summary</h1><p>In this chapter we examined how dependency properties and routed events are implemented in WPF. The <code>DependencyObject</code>, which serves as a base class for WPF elements, provides a collection of key/value pairs, where the key is a <code>DependencyProperty</code> and the value is the object it is set to. This collection can be accessed through the <code>GetValue()</code> and <code>SetValue()</code> methods, and is also used as a backing store for regular C# properties. We also saw that we can register callbacks on dependency properties to execute logic when the property is changed. The <code>UIElement</code>, which also serves as a base class for WPF elements, provided similar functionality for registering routed event listeners, whose key is <code>RoutedEvent</code>. We saw how these routed events could &ldquo;bubble&rdquo; up the elements tree, or &ldquo;tunnel&rdquo; down it, and how marking the event <code>Handled</code> property would stop it. Finally, we discussed the MVVM architecture, which works well with WPF applications to keep our code manageable.</p><p>We also created an example control using these ideas. The full project can be found <a href=https://github.com/ksu-cis/CustomDependencyObjectExample rel=external target=_blank>here</a>.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis400/commit/681e5c9c43e3ac6de614c2cc74487702fd43cab7>Aug 10, 2023</a></p></div></div><script src=/cis400/js/clipboard.min.js?1737134602 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1737134602 defer></script><script src=/cis400/js/theme.js?1737134602 defer></script></body></html>