




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Event-Driven Programming on K-State CIS 400 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/index.html</link>
    <description>Recent content in Event-Driven Programming on K-State CIS 400 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/01-introduction/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/01-introduction/index.html</guid>
      <description>Event-Driven programming is a programming paradigm where the program primarily responds to events - typically generated by a user, but also potentially from sensors, network connections, or other sources. We cover it here because event-driven programming is a staple of graphical user interfaces. These typically display a fairly static screen until the user interacts with the program in some meaningful way - moving or clicking the mouse, hitting a key, or the like.</description>
    </item>
    <item>
      <title>Message Loops</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/02-message-loop/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/02-message-loop/index.html</guid>
      <description>At the heart of every Windows program (and most operating systems), is an infinitely repeating loop we call the message loop and a data structure we call a message queue (some languages/operating systems use the term event instead of message). The message queue is managed by the operating system - it adds new events that the GUI needs to know about (i.e. a mouse click that occurred within the GUI) to this queue.</description>
    </item>
    <item>
      <title>Event Handlers</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/03-event-handlers/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/03-event-handlers/index.html</guid>
      <description>In C#, we use event handlers (sometimes called event listeners in other languages) to register the behavior we want to happen in response to specific events. You&amp;rsquo;ve probably already used these, i.e. declaring a handler:
private void OnEvent(object sender, EventArgs e) { // TODO: Respond to the event }Most event handlers follow the same pattern. They do not have a return value (their return type is void), and take two parameters.</description>
    </item>
    <item>
      <title>Declaring Events</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/04-declaring-events/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/04-declaring-events/index.html</guid>
      <description>Up to this point, you&amp;rsquo;ve probably only used events that were defined on library objects, like the Button&amp;rsquo;s Click event. However, you can also declare events in your own classes, and even create new event types.
In order to attach an event handler to an object in C#, we must first declare that that object has the corresponding event. To do so, we need both a name for the event, and a delegate.</description>
    </item>
    <item>
      <title>Events as Messages</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/05-events-as-messages/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/05-events-as-messages/index.html</guid>
      <description>It might be coming clear that in many ways, events are another form of message passing, much like methods are. In fact, they are processed much the same way: the Invoke() method of the event calls each attached event handler in turn.
Tip Regular event invocation in C# is synchronous, just as is method calling - invoking an event passes execution to the event handlers one at a time the same way calling a method hands program execution to the method.</description>
    </item>
    <item>
      <title>PropertyChanged</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/06-property-changed/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/06-property-changed/index.html</guid>
      <description>We often have classes which encapsulate data we might need to look at. For example, we might have a &amp;ldquo;Smart&amp;rdquo; dog dish, which keeps track of the amount of food it contains in ounces. So it exposes a Weight property.
Now let&amp;rsquo;s assume we have a few possible add-on products that can be combined with that smart bowl. One is a &amp;ldquo;dinner bell&amp;rdquo;, which makes noises when the bowl is filled (ostensibly to attract the dog, but mostly just to annoy your neighbors).</description>
    </item>
    <item>
      <title>Inheritance And Events</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/07-inheritance-and-events/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/07-inheritance-and-events/index.html</guid>
      <description>Considering that C# was developed as an object-oriented language from the ground up, you would expect that events would be inheritable just like properties, fields, and methods. Unfortunately this is not the case. Remember, the C# language is compiled into intermediate language to run on the .NET Runtime, and this Runtime proceeded C# (it is also used to compile Visual Basic), and the way events are implemented in intermediate language does not lend itself to inheritance patterns.</description>
    </item>
    <item>
      <title>Routed Events</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/08-routed-events/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/08-routed-events/index.html</guid>
      <description>While events exist in Windows Forms, Windows Presentation Foundation adds a twist with their concept of routed events. Routed events are similar to regular C# events, but provide additional functionality. One of the most important of these is the ability of the routed event to &amp;ldquo;bubble&amp;rdquo; up the elements tree . Essentially, the event will be passed up each successive WPF element until one chooses to &amp;ldquo;handle&amp;rdquo; it, or the top of the tree is reached (in which case the event is ignored).</description>
    </item>
    <item>
      <title>CollectionChanged</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/09-collection-changed/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/09-collection-changed/index.html</guid>
      <description>The PropertyChanged event notifies us when a property of an object changes, which covers most of our GUI notification needs. However, there are some concepts that aren&amp;rsquo;t covered by it - specifically, when an item is added or removed from a collection. We use a different event, NotifyCollectionChanged to convey when this occurs.
The INotifyCollectionChanged Interface The INotifyCollectionChanged interface defined in the System.Collections.Specialized namespace indicates the collection implements the NotifyCollectionChangedEventHandler, i.</description>
    </item>
    <item>
      <title>Testing Generic Events</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/10-testing-generic-events/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/10-testing-generic-events/index.html</guid>
      <description>In the testing chapter, we introduced the XUnit assertion for testing events, Assert.Raises&amp;lt;T&amp;gt;. Let&amp;rsquo;s imagine a doorbell class that raises a Ring event when it is pressed, with information about the door, which can be used to do things like ring a physical bell, or send a text notification:
/// &amp;lt;summary&amp;gt; /// A class representing details of a ring event /// &amp;lt;/summary&amp;gt; public class RingEventArgs : EventArgs { private string _door; /// &amp;lt;summary&amp;gt; /// The identity of the door for which the doorbell was activated public string Door =&amp;gt; _door; /// &amp;lt;summary&amp;gt; /// Constructs a new RingEventArgs /// &amp;lt;/summary&amp;gt; public RingEventArgs(string door) { _door = door; } } /// &amp;lt;summary&amp;gt; /// A class representing a doorbell /// &amp;lt;/summary&amp;gt; public class Doorbell { /// &amp;lt;summary&amp;gt; /// An event triggered when the doorbell rings /// &amp;lt;/summary&amp;gt; public event EventHandler&amp;lt;RingEventArgs&amp;gt; Ring; /// &amp;lt;summary&amp;gt; /// The name of the door where this doorbell is mounted /// &amp;lt;/summary&amp;gt; public string Identifier {get; set;} /// &amp;lt;summary&amp;gt; /// Handles the end of the incubation period /// by triggering a Hatch event /// &amp;lt;/summary&amp;gt; public void Push() { Ring?</description>
    </item>
    <item>
      <title>Testing Custom Events</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/11-testing-custom-events/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/11-testing-custom-events/index.html</guid>
      <description>In the previous section, we discussed using XUnit&amp;rsquo;s Assert.Raises&amp;lt;T&amp;gt; to test generic events (events declared with the EventHandler&amp;lt;T&amp;gt; generic). However, this approach does not work with non-generic events, like PropertyChanged and CollectionChanged. That is why XUnit provides an Assert.PropertyChanged() method. Unfortunately, it does not offer a corresponding test for CollectionChanged. So to test for this expectation we will need to write our own assertions.
To do that, we need to understand how assertions in the XUnit framework work.</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/12-summary/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis400/2-desktop-development/03-events/12-summary/index.html</guid>
      <description>In this chapter we discussed the Windows Message Loop and Queue, and how messages provided to this loop are transformed into C# events by the Application class. We examined C#&amp;rsquo;s approach to events, which is a more flexible form of message passing. We learned how to write both C# event listeners and handlers, and how to invoke event handlers with Invoke(). We also learned how to create and trigger our own custom events with custom event arguments.</description>
    </item>
  </channel>
</rss>