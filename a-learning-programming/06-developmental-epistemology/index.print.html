<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Among these neo-Piagetian researchers is a group including Raymond Lister and Donna M. Teague whom applied these theories to the learning of computer science, formulating a theory Lister calls The Developmental Epistemology of Computer Programming. This theory describes the traits of programmers at each of the stages of development. In particular, they use a studentâ€™s ability to trace code (explain line-by-line what it does) as a demarcation between stages. Stage Traits Sensorimotor Cannot trace code with >= 50% accuracy Dominant problem-solving strategy is trial and error Preoperational Can trace code with >= 50% accuracy Traces without abstracting any meaning from the code Cannot see relationships between lines of code Struggles to make effective use of diagrammatic abstractions of code Dominant problem-solving strategy is quasi-random code changes and copious trial runs Concrete Operational Dominant problem-solving strategy is hasty design, futile patching Can establish purpose of code by working backwards from execution results Tends to reduce levels of abstraction to make concepts more understandable Formal Operational Uses hypothetico-deductive reasoning Reads code rather than traces to deduce purpose These stages reflect the progress the learner is making through accommodation, creating the mental structures needed to reason about programming."><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><meta name=twitter:description content="Among these neo-Piagetian researchers is a group including Raymond Lister and Donna M. Teague whom applied these theories to the learning of computer science, formulating a theory Lister calls The Developmental Epistemology of Computer Programming. This theory describes the traits of programmers at each of the stages of development. In particular, they use a studentâ€™s ability to trace code (explain line-by-line what it does) as a demarcation between stages. Stage Traits Sensorimotor Cannot trace code with >= 50% accuracy Dominant problem-solving strategy is trial and error Preoperational Can trace code with >= 50% accuracy Traces without abstracting any meaning from the code Cannot see relationships between lines of code Struggles to make effective use of diagrammatic abstractions of code Dominant problem-solving strategy is quasi-random code changes and copious trial runs Concrete Operational Dominant problem-solving strategy is hasty design, futile patching Can establish purpose of code by working backwards from execution results Tends to reduce levels of abstraction to make concepts more understandable Formal Operational Uses hypothetico-deductive reasoning Reads code rather than traces to deduce purpose These stages reflect the progress the learner is making through accommodation, creating the mental structures needed to reason about programming."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/a-learning-programming/06-developmental-epistemology/"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><meta property="og:description" content="Among these neo-Piagetian researchers is a group including Raymond Lister and Donna M. Teague whom applied these theories to the learning of computer science, formulating a theory Lister calls The Developmental Epistemology of Computer Programming. This theory describes the traits of programmers at each of the stages of development. In particular, they use a studentâ€™s ability to trace code (explain line-by-line what it does) as a demarcation between stages. Stage Traits Sensorimotor Cannot trace code with >= 50% accuracy Dominant problem-solving strategy is trial and error Preoperational Can trace code with >= 50% accuracy Traces without abstracting any meaning from the code Cannot see relationships between lines of code Struggles to make effective use of diagrammatic abstractions of code Dominant problem-solving strategy is quasi-random code changes and copious trial runs Concrete Operational Dominant problem-solving strategy is hasty design, futile patching Can establish purpose of code by working backwards from execution results Tends to reduce levels of abstraction to make concepts more understandable Formal Operational Uses hypothetico-deductive reasoning Reads code rather than traces to deduce purpose These stages reflect the progress the learner is making through accommodation, creating the mental structures needed to reason about programming."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Learning Programming"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2021-08-26T14:01:59-05:00"><meta itemprop=name content="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><meta itemprop=description content="Among these neo-Piagetian researchers is a group including Raymond Lister and Donna M. Teague whom applied these theories to the learning of computer science, formulating a theory Lister calls The Developmental Epistemology of Computer Programming. This theory describes the traits of programmers at each of the stages of development. In particular, they use a studentâ€™s ability to trace code (explain line-by-line what it does) as a demarcation between stages. Stage Traits Sensorimotor Cannot trace code with >= 50% accuracy Dominant problem-solving strategy is trial and error Preoperational Can trace code with >= 50% accuracy Traces without abstracting any meaning from the code Cannot see relationships between lines of code Struggles to make effective use of diagrammatic abstractions of code Dominant problem-solving strategy is quasi-random code changes and copious trial runs Concrete Operational Dominant problem-solving strategy is hasty design, futile patching Can establish purpose of code by working backwards from execution results Tends to reduce levels of abstraction to make concepts more understandable Formal Operational Uses hypothetico-deductive reasoning Reads code rather than traces to deduce purpose These stages reflect the progress the learner is making through accommodation, creating the mental structures needed to reason about programming."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2021-08-26T14:01:59-05:00"><meta itemprop=wordCount content="577"><title>Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/a-learning-programming/06-developmental-epistemology/ rel=canonical type=text/html title="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><link href=/cis400/a-learning-programming/06-developmental-epistemology/index.xml rel=alternate type=application/rss+xml title="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><link href=/cis400/a-learning-programming/06-developmental-epistemology/tele.html rel=alternate type=text/html title="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><link href=/cis400/a-learning-programming/06-developmental-epistemology/embed.html rel=alternate type=text/html title="Developmental Epistemology of Computer Programming :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1719517097 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1719517097 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1719517097 rel=stylesheet><link href=/cis400/css/auto-complete.css?1719517097 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1719517097 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1719517097 rel=stylesheet><link href=/cis400/css/fonts.css?1719517097 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1719517097 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1719517097 rel=stylesheet><link href=/cis400/css/theme-auto.css?1719517097 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-auto.css?1719517097 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1719517097 rel=stylesheet><link href=/cis400/css/print.css?1719517097 rel=stylesheet media=print><link href=/cis400/css/format-print.css?1719517097 rel=stylesheet><script src=/cis400/js/variant.js?1719517097></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1719517097 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis400/a-learning-programming/06-developmental-epistemology/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis400/a-learning-programming/><span itemprop=name>Learning Programming</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Developmental Epistemology of Computer Programming</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/a-learning-programming/05-piaget/ title="Jean Piaget (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/a-learning-programming/07-summary/ title="Summary (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=developmental-epistemology-of-computer-programming>Developmental Epistemology of Computer Programming</h1><p>Among these neo-Piagetian researchers is a group including Raymond Lister and Donna M. Teague whom applied these theories to the learning of computer science, formulating a theory Lister calls <em>The Developmental Epistemology of Computer Programming</em>. This theory describes the traits of programmers at each of the stages of development. In particular, they use a student&rsquo;s ability to <em>trace</em> code (explain line-by-line what it does) as a demarcation between stages.</p><table><tr><th>Stage</th><th>Traits</th></tr><tr><td>Sensorimotor</td><td><ul><li>Cannot trace code with >= 50% accuracy</li><li>Dominant problem-solving strategy is trial and error</li></ul></td></tr><tr><td>Preoperational</td><td><ul><li>Can trace code with >= 50% accuracy</li><li>Traces without abstracting any meaning from the code</li><li>Cannot see relationships between lines of code</li><li>Struggles to make effective use of diagrammatic abstractions of code</li><li>Dominant problem-solving strategy is quasi-random code changes and copious trial runs</li></ul></td></tr><tr><td>Concrete Operational</td><td><ul><li>Dominant problem-solving strategy is hasty design, futile patching</li><li>Can establish purpose of code by working backwards from execution results</li><li>Tends to reduce levels of abstraction to make concepts more understandable</li></ul></td></tr><tr><td>Formal Operational</td><td><ul><li>Uses hypothetico-deductive reasoning</li><li>Reads code rather than traces to deduce purpose</li></ul></td></tr></table><p>These stages reflect the progress the learner is making through <em>accommodation</em>, creating the mental structures needed to reason about programming. An expert has developed these structures, which reflect patterns in how code is written - that is why an expert no longer traces code - they can <em>see</em> the patterns in the code and immediately grasp its action and purpose. In contrast, the novice must deduce the result of each line of code, put those understandings together, and then deduce what it is doing overall.</p><p>Writing a program is similar, the expert begins with a clear picture of the patterns she must employ, and focuses on fleshing those out, while a novice must create the program &lsquo;from whole cloth&rsquo;, reasoning out each step of the process. They are not yet capable of reasoning about the program they are writing in the abstract.</p><p>This also helps explain why learning to program can be so hard. Abstraction is considered a central tool in programming; we use abstractions constantly to simplify and make programs more understandable to other programmers. Consider a higher-level programing language, like C#. Each syntax element is an abstraction for a more complex machine-level process. The statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>x</span> <span class=p>+=</span> <span class=m>2</span><span class=p>;</span></span></span></code></pre></div><p>Stands in for machine instructions along the lines of:</p><div class=highlight><pre tabindex=0><code>PUSH REG5 TO REG1
PUSH 2 TO REG2
ADD REG1 AND REG2
PUSH REG3 TO REG5</code></pre></div><p>Which are in turn, simplifications and abstractions of the actual process of adding the two binary values in register 1 and register 2 (remember studying binary math in CIS 115)?</p><p>Also, many of the productivity tools created to support expert programmers (i.e. automatic code completion) may actually <em>hamper</em> your learning, as they alleviate the need to carry out part of the process you are learning. Consider turning these features off in your development environment until you have developed fluency as a programmer.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>To turn off autocomplete in Visual Studio:</p><ul><li>From Visual Studio, select <strong>&ldquo;Tools&rdquo; > &ldquo;Options&rdquo;</strong>.</li><li>Select <strong>&ldquo;Text Editor&rdquo;</strong> in the left pane.</li><li>Select the language you are using (C#, C++, Basic, etc.).</li><li>For C# and Basic, choose <strong>&ldquo;IntelliSense&rdquo;</strong>. For C or C++, choose <strong>&ldquo;Advanced&rdquo;</strong>, then scroll to the <strong>&ldquo;IntelliSense&rdquo;</strong> section.</li><li>For C# and Basic, check the <strong>&ldquo;Show completion list after a character is typed&rdquo;</strong> to disable it. For C/C++, you will have a few options, such as <strong>&ldquo;Disable Auto Updating&rdquo;</strong>, <strong>&ldquo;Disable Squiggles&rdquo;</strong>, and <strong>&ldquo;Disable #include Auto Complete&rdquo;</strong>. Set any of these to <strong>&ldquo;True&rdquo;</strong> to turn them off.</li></ul></div></div><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Nathan Bean
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis400/commit/10f668fa85f121db632fdae4831d8bb53a9c48ab>Aug 26, 2021</a></p></div></div><script src=/cis400/js/clipboard.min.js?1719517097 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1719517097 defer></script><script src=/cis400/js/theme.js?1719517097 defer></script></body></html>