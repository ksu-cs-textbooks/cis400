




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="K-State CIS 400 Textbook">
    <meta name="author" content="Nathan Bean">
    <title>Working With Disposables :: K-State CIS 400 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis400/3-web-development/04-apis/03-working-with-disposables/index.html" rel="canonical" type="text/html" title="Working With Disposables :: K-State CIS 400 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis400/3-web-development/04-apis/03-working-with-disposables/index.xml" rel="alternate" type="application/rss+xml" title="Working With Disposables :: K-State CIS 400 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis400/3-web-development/04-apis/03-working-with-disposables/index.print.html" rel="alternate" type="text/html" title="Working With Disposables :: K-State CIS 400 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis400/3-web-development/04-apis/03-working-with-disposables/tele.html" rel="alternate" type="text/html" title="Working With Disposables :: K-State CIS 400 Textbook">
    
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/fontawesome-all.min.css?1713900709" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis400/css/fontawesome-all.min.css?1713900709" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/nucleus.css?1713900709" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/auto-complete.css?1713900709" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis400/css/auto-complete.css?1713900709" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/perfect-scrollbar.min.css?1713900709" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/fonts.css?1713900709" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis400/css/fonts.css?1713900709" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/theme.css?1713900709" rel="stylesheet">
    
    
    
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/theme-light-theme.css?1713900709" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/variant.css?1713900709" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/print.css?1713900709" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/ie.css?1713900709" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis400/js/url.js?1713900709"></script>
    
    
    
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis400/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis400/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis400/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis400/css/custom.css?1713900709" rel="stylesheet">

    
  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis400/3-web-development/04-apis/03-working-with-disposables/embed.html">
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    
<p>In the previous section, we looked at a line of code that included the keyword <code>using</code> in a way you haven&rsquo;t probably seen it before:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Stream responseStream = response.GetStream() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO: Use the responseStream</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Let&rsquo;s examine this statement in more detail.  This use of <code>using</code> is a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement" target="_blank">using statement</a>
, not to be confused with a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive" target="_blank">using directive</a>
.</p>
<p>When you put a statement like <code>using System.Text</code>, you are using the <em>using directive</em>, which instructs the compiler to use types in the corresponding namespace without needing to provide the fully qualified namespace. You&rsquo;ve been using this technique for some time, so it should be familiar to you.</p>
<p>In contrast, the <em>using statement</em> is used in the body of your code in conjunction with an object implementing the <code>IDisposable</code> interface.  Objects that implement this interface have a <code>Dispose()</code> method, which needs to be called when you are done with them.  These kinds of objects typically access some resource from outside of the program, which needs to be released when you are done with it.</p>
<h4 id="managed-vs-unmanaged-resources">Managed vs. Unmanaged Resources</h4>
<p>To understand this better, let&rsquo;s talk about <em>managed</em> vs. <em>unmanaged</em> resources.  We say a resource is <em>managed</em> when obtaining and releasing it is handled by the language.  Memory is a great example of this.  In C#, we are using <em>managed memory</em>.  When we invoke a constructor or declare an array, the interpreter automatically creates the memory we need to hold them.</p>
<p>In contrast, C uses <em>unmanaged memory</em>.  When we want to create an array, we must <em>allocate</em> that memory with <code>alloc()</code>, <code>calloc()</code>, or <code>malloc()</code> function call.</p>
<p>This might not seem very different, until we are done with the array.  In C#, we can simply let it fall out of scope, knowing the garbage collector should eventually free that memory.  But in a C program, we must manually free the memory with a call to <code>free()</code>.</p>
<p>Sometimes in C#, we need to access some resource in a way that is unmanaged - in which case, we must be sure to free the resource when we are done with it.</p>
<h4 id="idisposable">IDisposable</h4>
<p>The <code>IDisposable()</code> interface provides a standard way of handling this kind of situation. It requires any class implementing it to define a <code>Dispose()</code> method that frees any unmanaged resources.  A <em>stream</em> (the data being read in from a file, the network, or a terminal) is a good example of an unmanaged resource - the stream is actually created by the operating system, and the <code>Stream</code> object (a <code>FileStream</code>, <code>BufferedStream</code>, etc) is a C# object providing access to it.</p>
<p>Let&rsquo;s focus on a <code>FileStream</code> for a moment.  One is created every time you ask the operating system to open a file, i.e.:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>FileStream fs = File.OpenRead(<span style="color:#e6db74">&#34;somefile.txt&#34;</span>);</span></span></code></pre></div><p>The <code>File.OpenRead()</code> method asks the operating system to provide a stream to the file named <code>&quot;somefile.txt&quot;</code>.  We can then read that stream until we reach the end of file marker (indicating we&rsquo;ve read the entire file):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">byte</span> data = fs.ReadByte();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Invariant: while there are bytes in the file to read</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(data != -<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Write the current byte to the console</span>
</span></span><span style="display:flex;"><span>  System.Out.Write(data);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Read the next byte</span>
</span></span><span style="display:flex;"><span>  data = fs.ReadByte();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Once we&rsquo;ve finished reading the file, we need to call <code>Dispose()</code> on the stream to tell the operating system that we&rsquo;re done with it:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>fs.Dispose();</span></span></code></pre></div><p>If we don&rsquo;t, then the operating system will assume we&rsquo;re still working with the file, and refuse to let any other program read it.  Including our own program, if we were to run it again.</p>
<p>But what happens if an error occurs while reading the file? We&rsquo;ll never reach the call to <code>Dispose()</code>, so we&rsquo;ll <em>never free the file</em>!  In order to access it, we&rsquo;d have to restart the computer.  Not great.</p>
<p>We <em>could</em> manage this with a <code>try/catch/finally</code>, i.e.:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">try</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  FileStream fs = File.OpenRead(<span style="color:#e6db74">&#34;somefile.txt&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">byte</span> data = fs.ReadByte();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Invariant: while there are bytes in the file to read</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(data != -<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Write the current byte to the console</span>
</span></span><span style="display:flex;"><span>    System.Out.Write(data);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read the next byte</span>
</span></span><span style="display:flex;"><span>    data = fs.ReadByte();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  fs.Dispose();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span>(Exception e) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Do something with e</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">finally</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  fs.Dispose();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>But you have to catch all exceptions.</p>
<h4 id="using-statement">Using Statement</h4>
<p>A using statement operates similarly, but takes far less typing:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> FileStream fs = File.OpenRead(<span style="color:#e6db74">&#34;somefile.txt&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">byte</span> data = fs.ReadByte();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Invariant: while there are bytes in the file to read</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(data != -<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Write the current byte to the console</span>
</span></span><span style="display:flex;"><span>    System.Out.Write(data);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read the next byte</span>
</span></span><span style="display:flex;"><span>    data = fs.ReadByte();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>It also comes with some benefits.  One, it creates a new scope (within the <code>{}</code> following the using statement).  If for some reason the stream can&rsquo;t be opened, this scope is skipped over.  Similarly it jumps execution to the end of the scope if an error occurs.  Finally, it <em>automatically</em> calls <code>Dispose()</code> when the scope ends.</p>
<h4 id="syntax-shorthand">Syntax Shorthand</h4>
<p>As of C# 8.0, a shorthand for the using statement that omits the scope markers (the <code>{}</code>) is available.  In this case, the scope is from the start of the <code>using</code> statement to the end of its containing scope (usually a method):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> FileStream fs = File.OpenRead(<span style="color:#e6db74">&#34;somefile.txt&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span> data = fs.ReadByte();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Invariant: while there are bytes in the file to read</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(data != -<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Write the current byte to the console</span>
</span></span><span style="display:flex;"><span>  System.Out.Write(data);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Read the next byte</span>
</span></span><span style="display:flex;"><span>  data = fs.ReadByte();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>This format can be nice when you need to nest multiple <code>using</code> statements, but I would suggest sticking with the scoped version until you are comfortable with the concepts involved.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis400/js/clipboard.min.js?1713900711" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis400/js/perfect-scrollbar.min.js?1713900711" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis400/js/theme.js?1713900711" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis400/js/embed-iframe.js?1713900711 defer"></script>
  </body>
</html>
