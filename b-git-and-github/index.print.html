<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="Be a Better Version"><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git and GitHub :: K-State CIS 400 Textbook"><meta name=twitter:description content="Be a Better Version"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/b-git-and-github/"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Git and GitHub :: K-State CIS 400 Textbook"><meta property="og:description" content="Be a Better Version"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Git and GitHub :: K-State CIS 400 Textbook"><meta itemprop=description content="Be a Better Version"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:29:34-05:00"><meta itemprop=wordCount content="4"><title>Git and GitHub :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/ rel=canonical type=text/html title="Git and GitHub :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/index.xml rel=alternate type=application/rss+xml title="Git and GitHub :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/tele.html rel=alternate type=text/html title="Git and GitHub :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/embed.html rel=alternate type=text/html title="Git and GitHub :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1724766102 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1724766102 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1724766102 rel=stylesheet><link href=/cis400/css/auto-complete.css?1724766102 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1724766102 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1724766102 rel=stylesheet><link href=/cis400/css/fonts.css?1724766102 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1724766102 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1724766102 rel=stylesheet><link href=/cis400/css/theme-auto.css?1724766102 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-auto.css?1724766102 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1724766102 rel=stylesheet><link href=/cis400/css/print.css?1724766102 rel=stylesheet media=print><link href=/cis400/css/format-print.css?1724766102 rel=stylesheet><script src=/cis400/js/variant.js?1724766102></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1724766102 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis400/b-git-and-github/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Git and GitHub</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/a-learning-programming/07-summary/ title="Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis400/b-git-and-github/01-introduction/ title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter B</div><h1 id=git-and-github>Git and GitHub</h1><p>Be a Better Version</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Git and GitHub</h1><article class=default><header class=headline></header><h1 id=introduction>Introduction</h1><p>Code version control is a staple of modern software development. So it&rsquo;s a good idea to learn and practice it <em>now</em>, so it becomes a core element of your software development practice. This appendix covers one of the most popular distributed version control software in use today - Git. It also covers one of the most popular online platforms for hosting remote Git repositories - GitHub. (Hint: Despite the tendency for many programmers to use the names interchangeably, they <em>aren&rsquo;t</em> the same thing!)</p><p>Over the next few sections we&rsquo;ll take you through the basic concepts of how Git actually works, and then show you the most common <em>workflows</em> you&rsquo;ll find yourself using with Git.</p><h2 id=key-terms>Key Terms</h2><p>Some key terms to learn in this chapter are:</p><ul><li>Version Control</li><li>Git</li><li>GitHub</li><li>Repository</li><li>Commit</li><li>Branch</li><li>Remote</li><li>Clone</li><li>Origin</li><li>Push</li><li>Pull</li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=version-control-software>Version Control Software</h1><p>Have you ever been working on a paper for a class, and stopped every now and then to save it under a slightly different name, i.e. &ldquo;Paper draft 1.docx&rdquo;, &ldquo;Paper draft 2.docx&rdquo;, &ldquo;Paper final draft.docx&rdquo;, &ldquo;Paper final draft with Merge suggestions.docx&rdquo;, and so on?</p><p>Effectively what you were doing was <em>version control</em> - keeping old copies of a project around. This can be a lifesaver if your current file gets corrupted and becomes unusable. It can also be helpful to go back and see older versions, perhaps to see what a section looked like <em>before</em> your last set of changes. It might also be handy if that last major revision just isn&rsquo;t working, and you want to go back to what the paper looked like <em>before</em> you started making changes.</p><p>Now think about programming projects, which involve <em>multiple</em> files. You could copy your project directory and rename it&mldr; but it&rsquo;s a lot of effort, and also chews up memory on your computer. And have you ever found those multiple folders/files become difficult to navigate and sort through? Also, what happens if your entire <em>computer</em> gets trashed? Or stolen? Where are you with your multiple copies of files/directories then?</p><p>Version control software was invented to help solve these problems, along with one more pressing issue - working with others and <em>sharing</em> those code files between everyone on the team. No doubt you probably have or have heard some horror stories from CIS 115 or other courses were one member of the team accidentally overwrote the content that the rest of the team had painstakingly added to the group&rsquo;s Wiki page&mldr;</p><p>Ideal version control software therefore:</p><ul><li>Provides a mechanism for saving incremental changes to a project</li><li>Allows you to easily revert back to an earlier version of the project</li><li>Can be used to back up the project to a separate machine/location (preferably with some geographic distance, so if your workplace is destroyed by fire, flood, or other disaster your work isn&rsquo;t forever lost)</li><li>Allows different team members to contribute to a shared project without overwriting your teammates&rsquo; work</li></ul><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=git>Git</h1><p>Git is one of the many version control programs that has been developed to tackle these challenges, and is currently one of the most popular. In part, this is because it does a <em>very good job</em> at tackling each of those issues we just discussed. Of course, it can only do this if you are using it as it was intended to be used&mldr; so it&rsquo;s a good idea to spend a bit of time learning those details (though, as the authors of xkcd suggest, many people don&rsquo;t):</p><p><a href=#R-image-38dce91fabbb59dd681ad996fabaaa05 class=lightbox-link><img alt="xkcd&rsquo;s take on Git" class="border lazy lightbox noshadow figure-image" loading=lazy src=https://imgs.xkcd.com/comics/git.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-38dce91fabbb59dd681ad996fabaaa05><img alt="xkcd&rsquo;s take on Git" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=https://imgs.xkcd.com/comics/git.png></a></p><p>First, to use Git you need to install a program known as a Git client on your computer. Most people use the open-source command-line <code>git</code> client available from <a href=https://git-scm.com/downloads rel=external target=_blank>https://git-scm.com/downloads</a>, but there are other clients that provide GUI experiences and the like. Here we&rsquo;ll focus on the command-line version.</p><p>You can also learn more from the official <a href=https://git-scm.com/doc rel=external target=_blank>Git Documentation</a> or the free online <a href=https://git-scm.com/book/en/v2 rel=external target=_blank>Pro Git Book</a>. These are great resources for expanding your Git knowledge, as this appendix is only going to hit the conceptual high points of Git and focus on the workflows you&rsquo;ll be using for this class.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=git-initialization>Git Initialization</h1><a href="https://www.youtube.com/watch?v=zYXS4ILE_Mo">YouTube Video</a><p>Git converts an ordinary directory (folder) on our computer into a <em>git repository</em>, allowing you to save different versions of the directory&rsquo;s contents as you make changes to that directory. Invoking the <strong>git init</strong> command within the top directory of your project starts this process:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>$</span> <span class=nx>git</span> <span class=nx>init</span> 
</span></span></code></pre></div><p>The data describing these changes and how to switch to them is stored in a subdirectory the Git client creates in the top project directory named <em>.git</em>. This folder is normally hidden from the user on most operating systems, though you can reveal it by tweaking your OS settings. All the <code>git</code> commands modify the contents of that folder. This approach has one really great benefit - if you copy your project folder into a new location, your repository information goes with it!</p><p>If you&rsquo;re curious about the structure of the <em>.git</em> folder, Pierre DeWulf has a <a href=https://hashnode.com/post/understanding-git-for-real-by-exploring-the-git-directory-cjt44mqmi0001a6s2a8el9a4t rel=external target=_blank>good post discussing it</a> on his blog. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> Essentially, every time you <em>commit</em> (save your current changes), Git creates a new entry representing the state of your files at that point, including an identifying hash (to identify the commit), the previous (parent) commit&rsquo;s hash, a comment describing the commit, the date and time of the commit, and the identity of the user making the commit. We can use this information to restore the project directory to <em>any one of the commits we&rsquo;ve made</em>.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Because Git places all of its repository information in the <em>.git</em> folder, deleting it will make the directory no longer be a repository. All committed changes will be lost, and you will no longer be able to revert your project files to earlier versions.</p></div></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Pierre DeWulf, <a href=https://hashnode.com/post/understanding-git-for-real-by-exploring-the-git-directory-cjt44mqmi0001a6s2a8el9a4t rel=external target=_blank>&ldquo;Understanding git for real by exploring the .git directory&rdquo;</a>, <em>daolf.com</em>, Mar 11, 2019.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=staging-and-committing>Staging and Committing</h1><a href="https://www.youtube.com/watch?v=isp3dsbZjss">YouTube Video</a><p>It is important to understand that Git doesn&rsquo;t save the changes to <em>every</em> file in the directory when you create a commit - it only saves those files you have <em>staged</em> to be committed. This extra step often confuses new Git users, but it exists to give you full control over what gets committed into your repository.</p><p><a href=#R-image-2b25bfe616d6adf0f527f992ac8972b9 class=lightbox-link><img alt="Staging Diagram" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.5.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-2b25bfe616d6adf0f527f992ac8972b9><img alt="Staging Diagram" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.5.3.png></a></p><p>It may help to understand how Git thinks about files. Files in your repository directory fall into one of five categories - <em>untracked</em>, <em>unstaged</em>, <em>staged</em>, <em>committed</em>, and <em>ignored</em>.</p><p><em>Untracked</em> files are those that have never been added to the repository. As far as the repository is concerned, they don&rsquo;t exist. If you were to delete one, you cannot restore it, as the repository has no saved version of it. Mostly these are files that have recently been created.</p><p><em>Unstaged</em> files are those that are tracked, but have at least some changes that have not been committed. These are either new files that have just been added to the repository&rsquo;s index with a <strong>git add</strong> command, or files that have been altered since the last commit.</p><p><em>Staged</em> files are those that will be included in the next commit. They are added to the list of staged files with the <strong>git add</strong> command, and will be committed with the <strong>git commit</strong> command.</p><p><em>Committed</em> files are those whose current state has been saved as a commit. In other words, they are &ldquo;safe&rdquo; as they can be restored from that commit with a <strong>git checkout</strong> command.</p><p><em>Ignored</em> files are those whose path matches the pattern in the <em>.gitignore</em> file. We&rsquo;ll come back to this idea shortly.</p><p>You can check for the status of your files in the repository at any time with the <strong>git status</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git status </code></pre></div><p>This will print the status of all uncommitted files:</p><p><a href=#R-image-6da828179850e63f3060658b1745564b class=lightbox-link><img alt="The output of git status" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.5.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6da828179850e63f3060658b1745564b><img alt="The output of git status" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.5.1.png></a></p><p>There are four files in the <em>ff</em> directory: <em>example0.txt</em>, <em>example1.txt</em>, <em>example2.txt</em>, and <em>example3.txt</em>. In the output above, we see:</p><ul><li><em>example0.txt</em> was committed at some point, but now has changes. Git helpfully lets us know we can undo those changes and restore the committed version with the command <code>$ git checkout -- example0.txt</code>, or add this file to those staged with <code>$ git add example0.txt</code>.</li><li><em>example1.txt</em> does not appear in the status message, as it is already committed and has no changes.</li><li><em>example2.txt</em> is a new file (it has never been committed), and is staged to be committed.</li><li><em>example3.txt</em> is also a new file, but is not staged to be committed.</li></ul><p>Interestingly, you can still change a staged file. If you do so, Git keeps track of the staged but not committed changes, <em>and</em> the new, unstaged modifications. For example, if we change <em>example2.txt</em> and run <strong>git status</strong> again, we&rsquo;ll see:</p><p><a href=#R-image-c68646167ec81a6e3404efea65614bb0 class=lightbox-link><img alt="The output of git status" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.5.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c68646167ec81a6e3404efea65614bb0><img alt="The output of git status" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.5.2.png></a></p><p>Notice <em>example2.txt</em> now has <em>two</em> statuses - corresponding to the staged and unstaged changes!</p><h3 id=committing-changes>Committing Changes</h3><p>With this understanding in mind, the standard way of committing changes is to combine a <strong>git add</strong> command and a <strong>git commit</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git add .
$ git commit -m &#34;&lt;a message about the commit&gt;&#34;</code></pre></div><p>The <code>git add .</code> adds <em>all</em> untracked and unstaged files (making them <em>staged</em>), and <code>git commit</code> commits our staged files.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=ignoring-files>Ignoring Files</h1><a href="https://www.youtube.com/watch?v=LjUpxnmgdOQ">YouTube Video</a><p>Typically there are some files in a project that we <em>never</em> want to commit. For example, compilers often create temporary or intermediate files during the compilation process, and these will be recreated every time we re-compile. We also usually don&rsquo;t want to commit the compiled binary files either, as we can always compile our code to get a fresh copy. Not saving these files means our repository takes up less memory, and Git operations are faster.</p><p>And if our project involves some configuration files with sensitive information (passwords, shared secrets, etc), we don&rsquo;t want to commit these to our repository either - especially if it will be publicly visible on GitHub.</p><p>We can specify the patterns of files Git should ignore with a special text file named <em>.gitignore</em>. Inside that file, we specify file path patterns. Any file matching one of these patterns is effectively ignored by Git. However, if we have already <em>committed</em> a file to the repository, and then added our <em>.gitignore</em> file, the committed file remains in the repository. For this reason, we <em>always</em> want to add our <em>.gitignore</em> as we create the repository.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>While it is technically possible to completely remove a file accidentally committed to a Git repository, the process is not easy to complete correctly, and a mistake often means the file is still accessible to a skilled adversary. In those situations, it may be best to delete the <em>.git</em> folder and create a new repository.</p></div></div><p>GitHub provides a <a href=https://github.com/github/gitignore rel=external target=_blank>helpful repository of <em>.gitignore</em> files</a> for specific programming languages and platforms. An easy trick is to find the one for the language you are interested in, open it in its raw form, and copy/paste its text into your <em>.gitignore</em> file. For this class, you&rsquo;ll want to use the <a href=https://raw.githubusercontent.com/github/gitignore/master/VisualStudio.gitignore rel=external target=_blank>Visual Studio .gitignore</a>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=reverting-changes>Reverting Changes</h1><p>As we suggested earlier in the chapter, one of the most important uses of a version control system is to allow you to revert to an earlier version of your code. To ask Git to list the available commits, you can use the <strong>git log</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git log</code></pre></div><p>This should print a list of the commits and their details, with the newest commit first:</p><p><a href=#R-image-d902784f81e660bb1bb3b2fe18c2e27d class=lightbox-link><img alt="git log output" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.7.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-d902784f81e660bb1bb3b2fe18c2e27d><img alt="git log output" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.7.1.png></a></p><p>Notice each commit is identified by a hash, date, and commit message. This is why a good commit message is important - it helps to let us know what we changed (and therefore what changes we would be undoing if we reverted to that commit). If we wanted to revert to an earlier version, we would use the <strong>git checkout</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git checkout [hash]</code></pre></div><p>Where <code>[hash]</code> is the hash of the commit, i.e. <code>cec94d9078c036b6ebd374cde0d7e400a8a94ebd</code> for the initial commit in the example.</p><p>This reverts your files to that point, and reports you are in a &lsquo;detached HEAD&rsquo; state, i.e. the commit loaded is not the latest one on this branch. Carlos Schults has an <a href=https://www.cloudbees.com/blog/git-detached-head rel=external target=_blank>excellent post describing this condition</a>. If you want to start working from this point (leaving your later changes out), best practice is to create a new branch to hold this commit. We&rsquo;ll look at branches next.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=branches>Branches</h1><a href="https://www.youtube.com/watch?v=dPzLr53-Geg">YouTube Video</a><p>Branches are a powerful mechanisms for working on different versions of your code. The name &ldquo;branch&rdquo; is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:</p><p><a href=#R-image-f261a0352486787e6ac1a12183ec7fd9 class=lightbox-link><img alt="Simple repository with one branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f261a0352486787e6ac1a12183ec7fd9><img alt="Simple repository with one branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.1.png></a></p><p>This default branch was historically named &ldquo;master&rdquo;, though recent practice has shifted to using the term &ldquo;main&rdquo;. GitHub provides <a href=https://github.com/github/renaming rel=external target=_blank>guidance and support for renaming existing project branches</a>.</p><p>At any node in the commit tree, we could create a new branching point with the command <strong>git branch [branchname]</strong> where we supply the branch name. The branch starts with exactly the same code as the current commit to main (or whatever branch we are branching from). Then we can check out the branch with <strong>git checkout [branchname]</strong>, using the name we supplied. Let&rsquo;s create and check out a branch named &ldquo;experiment&rdquo; in our above example:</p><div class=highlight><pre tabindex=0><code>$ git branch experiment
$ git checkout experiment</code></pre></div><p>We now have a new branch, experiment, branching from commit <strong>573ed9f</strong>:</p><p><a href=#R-image-3a82999ebcaad8fb2e21e34b75b7219a class=lightbox-link><img alt="The same repository with a new branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3a82999ebcaad8fb2e21e34b75b7219a><img alt="The same repository with a new branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.2.png></a></p><p>While &ldquo;experiment&rdquo; is the checked out branch, any commits we make are placed on it instead of the main branch. Let&rsquo;s assume we create two commits on the experiment branch; our tree will now look like:</p><p><a href=#R-image-1ed4c8ebf336505100527e833683fc99 class=lightbox-link><img alt="Two commits on the experimental branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-1ed4c8ebf336505100527e833683fc99><img alt="Two commits on the experimental branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.3.png></a></p><p>We can switch back to the main branch at any point with <strong>git checkout main</strong>. When we do so, our code will be reverted back to how it was in the last commit to the main branch (commit <strong>573ed9f</strong>). If it turns out our experiment was a flop, we can forget about the experiment branch and the changes we made to it - we&rsquo;re back to a clean working build at the point before we started the experiment.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>It is important to understand how commits and branches interact. When you check out a branch, the code in the repository is reverted to the last commit on that branch. And any new commits you make are saved to the currently checked out branch.</p><p>If you have <em>uncommitted</em> or <em>staged</em> changes in files, git will refuse to check out a branch until these are committed or stashed, as checking out the branch will overwrite those changes and they would be lost forever. In contrast, <em>unstaged</em> and <em>ignored</em> files are fine (as there is no committed version that will overwrite the file). Best practice is to commit your changes before switching branches, unless you want to throw the changes away.</p></div></div><p>If, on the other hand, we like the changes from the experiment, and want to add them to the main branch, we can <em>merge</em> those changes with the <strong>git merge [branchname]</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git merge experiment</code></pre></div><p>This merges the specified branch with the currently checked-out branch. Git accomplishes merging through a recursive strategy, which works very well. However, if both branches have had changes committed since the last shared commit, there is a possibility that some of those changes will overlap, and Git will not be able to determine which to use. This is called a <em>merge conflict</em> and must be resolved by you. See the <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/11-merge-conflicts/ rel=external target=_blank>merge conflict</a> section later for more details.</p><p>There are a number of reasons we might want to create a branch; let&rsquo;s examine some common use cases.</p><ul><li><p>Prototype branches - Let&rsquo;s say we wanted to try making some changes to our code that we aren&rsquo;t sure will work - basically, we are creating an experimental prototype. If this experiment doesn&rsquo;t end up succeeding, we would like to return to our current version of the project. This is exactly the scenario we walked through above.</p></li><li><p>Feature branches - Let&rsquo;s assume you have a working program you need to add a new feature to, but you still want to be able to access the working code. In this case, you can create a branch to work on that feature. That way, when your feature is only partially done, you can still switch back to your main branch and fix a bug, etc., without needing to remove or comment out your half-written feature code.</p></li><li><p>Personal branches - Let&rsquo;s say you&rsquo;re working with a team. You want to make sure that the main branch is always clean, ready-to-go code, and you don&rsquo;t want to have to deal with your teammate&rsquo;s half-written code (nor they with yours). Each team member can create their own branch to do their work on, and when it is tested and ready, merge that code into the main branch.</p></li></ul><p>Each of these approaches can (and usually is) used in conjunction with remote repositories. We&rsquo;ll take a look at that next.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=remote-repositories>Remote Repositories</h1><a href="https://www.youtube.com/watch?v=RFPd6Y_JRiw">YouTube Video</a><p>Git bills itself as a <em>distributed</em> version control system. This means it has no central server. Instead, we can create copies of the repository we call <em>remote repositories</em> with the <strong>git clone</strong> command. These copies can be placed anywhere - in another directory on your computer, or on a different computer on your network, or a computer accessed via the internet.</p><p>GitHub is a web service that specifically hosts remote git repositories and allows you to access them through both your git client <em>and</em> through a web (HTML/CSS/JS) interface. It was created primarily to provide a place to host publicly-accessible, open-source projects, though you can also use it to create private repositories. It is not the only such service available; <a href=https://bitbucket.org rel=external target=_blank>BitBucket</a> is a similar website more focused on closed-source projects, and the popular <a href=https://about.gitlab.com/ rel=external target=_blank>GitLab</a> is an open-source server for hosting Git projects you can install on your own systems. The Computer Science department at Kansas State University runs its own GitLab server to host projects developed as part of our research and extension mission.</p><p>At this point in your learning, you will likely be using a repository hosted on GitHub (usually created by GitHub classroom when you accept an assignment) as a remote repository you are cloning to one or more local repositories. For example, you&rsquo;ll likely clone your project on both your home computer and a lab computer so you can work in both locations.</p><p><a href=#R-image-f09235512e707fa3c4f3f0082ee3d94f class=lightbox-link><img alt="Common remote repository setup diagram" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.9.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f09235512e707fa3c4f3f0082ee3d94f><img alt="Common remote repository setup diagram" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.9.1.png></a></p><p>A clone is a copy of the project in its current state, including the hidden <em>.git</em> folder. This means it is <em>also</em> a complete git repository! The code will be in the same state as that of the currently active branch of the repo it was cloned from (for a project cloned from GitHub, this would be the main/master branch).</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>While the cloned repository is a copy of an existing repository, it will not contain <em>unstaged</em> or <em>ignored</em> files or directories, as these are not tracked by Git.</p></div></div><p>Thus, in our diagram above, the home, lab, and GitHub copies of our repository all start exactly the same, with commit <strong>ba4</strong>. But if we make and commit changes to one of those repositories, that repository will be <em>ahead</em> of the other repositories, which will not have that commit. We can see this in the diagram below, where we have added commit <strong>a4e</strong> to the repository on our Lab PC:</p><p><a href=#R-image-f4415a411a27354563fde68795de9bf0 class=lightbox-link><img alt="Lab PC with extra commit" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.9.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f4415a411a27354563fde68795de9bf0><img alt="Lab PC with extra commit" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.9.2.png></a></p><p>To get this same commit on our other remote repositories, we&rsquo;ll use <em>push</em> and <em>pull</em> commands.</p><h3 id=pushing>Pushing</h3><p>We can push commits from one repository to another one with a <strong>git push</strong> command. To use this command, we need to know the location of the remote repository, and what branch we want to push our changes to. When we clone an existing repository, Git automatically saves the location of that repository and gives it the name <em>origin</em>. Thus, we can copy our commit <strong>a4e</strong> from our Lab PC repository to GitHub with the <strong>git push</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git push origin main</code></pre></div><p>This pushes our new commit to the GitHub repository, so it now also has that commit:</p><p><a href=#R-image-5e802893f4da4a55b62e78ee3d4b4cf6 class=lightbox-link><img alt="GitHub with extra commit" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.9.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-5e802893f4da4a55b62e78ee3d4b4cf6><img alt="GitHub with extra commit" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.9.3.png></a></p><p>Because GitHub does not have a reference to our Home PC&rsquo;s repository, we can&rsquo;t push the commit there. Instead, we&rsquo;ll need to <em>pull</em> it directly from our home computer.</p><h3 id=pulling>Pulling</h3><p>As the repository on our home PC is also a clone of the GitHub repository, it kept track of the location of it using the name origin as well. So we can pull commits from that location (GitHub) using the <strong>git pull</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git pull origin main</code></pre></div><p>This copies any commits on the GitHub repository into the Home PC repository:</p><p><a href=#R-image-3d3b17bb03693022ac323d11350ca553 class=lightbox-link><img alt="Home PC with extra commit" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.9.4.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3d3b17bb03693022ac323d11350ca553><img alt="Home PC with extra commit" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.9.4.png></a></p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>If you push or pull changes to a repository that has extra commits, Git merges the extra commits with the pushed ones (as with the <strong>merge</strong> command). This can introduce the possibility of <em>merge conflicts</em> when Git is uncertain how to best combine two changes. These must be resolved by you as described in the <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/11-merge-conflicts/ rel=external target=_blank>merge conflict</a> section. For this reason, it is <em>always</em> best practice to pull changes into your local branch, fix any merge conflicts, create a new commit, and only then push it to the remote repository. This ensures that the main branch code is always in good shape.</p></div></div><h3 id=remote-repositories>Remote Repositories</h3><p>You can actually set up as many remote repositories as you want. In the diagram above, it would be possible to push or pull from the Lab PC to the Home PC directly, provided you had a publicly accessible URL for both (as we normally don&rsquo;t have static IP addresses for home networks, this is unlikely). You can add an additional remote repository with <strong>git remote add [name] [url]</strong>.</p><p>This can be helpful if you have a project you&rsquo;ve started on your home machine and want to push to GitHub. Create an empty project on GitHub (it must be completely empty, so don&rsquo;t create a default readme or license file). Then copy the clone URL and use it in your local Git command:</p><div class=highlight><pre tabindex=0><code>git remote add origin [remote url]</code></pre></div><p>where <code>[remote url]</code> is the GitHub clone url. After you&rsquo;ve done this, you can push your project to GitHub normally.</p><p>You can also list all remote repositories in a repo with:</p><div class=highlight><pre tabindex=0><code>git remote -v</code></pre></div><h4 id=remote-branches>Remote Branches</h4><p>You probably noticed in our push and pull examples above, we specified the <code>main</code> branch. You can also pull or push from other branches, i.e. if you had an <code>experiment</code> branch on your remote repository <code>origin</code> you could pull it with:</p><div class=highlight><pre tabindex=0><code>git pull origin experiment</code></pre></div><p>That would merge the <code>experiment</code> branch into the branch you currently have checked out.</p><p>Most often, we want to have our remote and local branches correspond to one another. In that case, we can first fetch all remote changes (without merging them into our local repository), which will also fetch any new remote branches. Then, we can create a new local branch that is synchronized to a new remote upstream branch. For example, suppose there is an <code>experiment</code> branch in our remote repository and we wish to create a new local <code>experiment</code> branch to track it. We can do:</p><div class=highlight><pre tabindex=0><code>git fetch
git checkout -b experiment origin/experiment</code></pre></div><p>After these commands, we have created the new local <code>experiment</code> branch which is currently synchronized with the remote <code>experiment</code> branch, and have checked out that new branch. As we make changes, we can use the <code>git push</code> and <code>git pull</code> shorthands, which will push and pull between the local <code>experiment</code> and remote <code>experiment</code> branches.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=feature-branches>Feature Branches</h1><p>This section summarizes the git commands you will need when creating feature branches for your semester-long project.</p><h2 id=1-create-and-check-out-a-local-branch-for-the-current-milestone>1. Create and check out a local branch for the current milestone</h2><p>When you start a new milestone, you need to create a local branch to hold your work. For example, if you wanted to create a feature branch for Milestone 0, you would do:</p><div class=highlight><pre tabindex=0><code>$ git branch ms0</code></pre></div><p>Next, check out your new branch. For our Milestone 0, we would do:</p><div class=highlight><pre tabindex=0><code>$ git checkout ms0</code></pre></div><h2 id=2-work-on-the-new-branch>2. Work on the new branch</h2><p>As you make progress on the current milestone, it is a good idea to add your changes to the remote repository. First, make sure you are on your milestone branch by doing:</p><div class=highlight><pre tabindex=0><code>$ git branch</code></pre></div><p>You will see a list of all local branches, with a <code>*</code> next to the currently checked out branch. You should see that the branch for the current milestone has a <code>*</code>. Then, add, commit, and push the changes for your branch to the remote repository:</p><div class=highlight><pre tabindex=0><code>$ git add .
$ git commit -m &#34;description of changes&#34;
$ git push</code></pre></div><p>The first time you do this, it will automatically create a remote branch with the same name.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>Depending on your <code>git</code> configuration, you may get this error when you <code>git push</code> or <code>git pull</code> on a local branch that has no remote counterpart:</p><div class=highlight><pre tabindex=0><code>fatal: The current branch &lt;branchName&gt; has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin &lt;branchName&gt;

To have this happen automatically for branches without a tracking
upstream, see &#39;push.autoSetupRemote&#39; in &#39;git help config&#39;.</code></pre></div><p>If you get this error, you can update your git configuration as follows:</p><div class=highlight><pre tabindex=0><code>git config --global push.autoSetupRemote true</code></pre></div><p>At that point you should be able to use <code>git push</code> or <code>git pull</code> and have it go automatically to/from the corresponding remote branch.</p><p>(If you still have errors, you will first need to update your version of git to get a version that is at least 2.37 &ndash; you can check the version number with <code>git --version</code>.)</p></div></div><h2 id=3-continuing-work-on-a-different-computer>3. Continuing work on a different computer</h2><p>Suppose you followed the steps above to start a milestone on your home computer (including pushing the latest changes for your milestone branch) and wanted to continue working on a lab computer.</p><h3 id=first-time-working-with-the-repository>First time working with the repository</h3><p>If this was your FIRST time working on this repository on the new computer, you would need to clone the repository to the new local machine. You can do this with Visual Studio&rsquo;s <em>File->Clone Repository</em> or from the terminal with <code>git clone [repoURL]</code>.</p><h3 id=first-time-working-with-current-branch>First time working with current branch</h3><p>If you have already cloned this repository to your current local computer but have not yet created a branch on this computer for the current milestone, you can use the <code>git checkout</code> option to both create a new local branch with the same name as a remote branch and switch to that new branch:</p><div class=highlight><pre tabindex=0><code>$ git checkout -b ms0 origin/ms0</code></pre></div><p>Replacing <code>ms0</code> with the current milestone branch.</p><h3 id=subsequent-times-working-with-a-branch>Subsequent times working with a branch</h3><p>If you have previously worked with the current milestone branch on your local computer, you need to first checkout that branch:</p><div class=highlight><pre tabindex=0><code>$ git checkout ms0</code></pre></div><p>Again, replacing <code>ms0</code> with the current milestone branch. Then, pull the latest changes for that branch from the remote repository to the local repository. If you do:</p><div class=highlight><pre tabindex=0><code>$ git pull origin ms0</code></pre></div><p>It will fetch updates from the remote <code>ms0</code> branch and merge them into the local <code>ms0</code> branch.</p><h2 id=merging-your-feature-branch-into-main>Merging your feature branch into main</h2><p>Finally, when you have finished the milestone, you&rsquo;ll want to merge your new changes from the feature branch into the main branch:</p><div class=highlight><pre tabindex=0><code>$ git checkout main 
$ git merge ms0</code></pre></div><p>(Again, replacing <code>ms0</code> with the current milestone branch name). Next, push the newly expanded main branch to GitHub:</p><div class=highlight><pre tabindex=0><code>$ git push origin main</code></pre></div><p>After that, you&rsquo;ll need to <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/12-release/ rel=external target=_blank>create a release</a> to turn in.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=merge-conflicts>Merge Conflicts</h1><a href="https://www.youtube.com/watch?v=UNfv8hdywEs">YouTube Video</a><p>When git merges commits from two different branches or remote repositories, it applies the committed changes from both. In many cases, this works seamlessly, but sometimes it results in <em>merge conflicts</em>. A conflict occurs when the same line(s) in a file were changed in both branches, and git is unsure of which to use.</p><p>Git will do several things in this scenario:</p><ol><li><p>It will report as output from that command that caused the conflict which file(s) in the repository contain conflicts, and</p></li><li><p>It will mark the conflicted sections of those files using a special format that shows the two versions of the code.</p></li></ol><p>An example of such a marking is:</p><div class=highlight><pre tabindex=0><code>public void PrintSomething() {  
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  if(testValue) {
=======
  if(otherTestValue) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt; some_branch
  Console.log(&#34;Something...&#34;);
}</code></pre></div><p>Here, we see two conflicting versions of one line: <code>if(testValue) {</code> and <code>if(otherTestValue){</code>. Additionally, we see markers delimiting the conflicting sections: <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>, <code>=======</code>, and <code>>>>>>>> some_branch</code>. We need to replace all of the code and delimiters with one final version of the code. This could be the first option, the second option, or a combination of the two:</p><div class=highlight><pre tabindex=0><code>public void PrintSomething() {  
  if(testValue &amp;&amp; otherTestValue) {
  Console.log(&#34;Something...&#34;);
}</code></pre></div><p>We need to do this for all conflicts in all conflicting files. Once they have all been resolved, we need to commit the changes with the commands:</p><div class=highlight><pre tabindex=0><code>$ git add .
$ git commit -m &#34;Fixed merge conflicts&#34;</code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=create-a-release>Create a Release</h1><p>When you are ready to turn in an assignment, you will need to create a <em>release tag</em>. A <em>tag</em> is nothing more than a specially named commit, and a <em>release</em> is a special tag created on GitHub to mark a specific version of the software.</p><h2 id=step-1---make-sure-_all_-your-code-is-on-github>Step 1 - Make sure <em>All</em> your code is on GitHub</h2><p>Since releases are created on GitHub, it is important to make sure you&rsquo;ve <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/05-staging-and-committing/ rel=external target=_blank>committed your changes</a> and have <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/09-remote-repositories/ rel=external target=_blank>pushed them to GitHub</a> before you create the release. You can check that all changes have been committed and pushed with the command:</p><div class=highlight><pre tabindex=0><code>$ git status</code></pre></div><p>If you see these messages:</p><div class=highlight><pre tabindex=0><code>Your branch is up to date with &#39;origin/main&#39;.

nothing to commit, working tree clean</code></pre></div><p>Then you are good to go. On the other hand, if you get the message <code>Your branch is # commits ahead of 'origin/main'</code>, then you need to <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/09-remote-repositories/#pushing rel=external target=_blank>push to master</a>, and if any files are listed as uncommitted, you first need to <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/05-staging-and-committing/#committing-changes rel=external target=_blank>commit them</a>.</p><h2 id=step-2---navigate-to-the-releases-on-github>Step 2 - Navigate to the Releases on GitHub</h2><p>Next, open your repository on Github. Towards the right side of the page you should see a link labeled &ldquo;Create a new release&rdquo;. Click it.</p><p><a href=#R-image-154c96b4254576d68f7789736b28580e class=lightbox-link><img alt="Releases Link" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.11.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-154c96b4254576d68f7789736b28580e><img alt="Releases Link" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.11.1.png></a></p><p>This will load the releases page for your repository.</p><h2 id=step-3---complete-the-release-form>Step 3 - Complete the Release Form</h2><p>You will need to fill out the release form, specifically the version and title, and then click the &ldquo;Publish Release&rdquo; button.</p><p><a href=#R-image-f5f086fcc64030901f00bb545126f5c6 class=lightbox-link><img alt="New Release Form" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.11.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f5f086fcc64030901f00bb545126f5c6><img alt="New Release Form" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.11.3.png></a></p><p>Releases use <em><a href=https://semver.org/ rel=external target=_blank>semantic versioning</a></em>, a numbering system that uses three numbers separated by periods (i.e. version 3.4.2). The first number is the <em>major</em> version - a change in this number indicates a major change in the associated software, i.e. a redesigned interface, a change in what methods are available, etc. The second number is the <em>minor</em> version. It indicates small feature additions to the software. Finally, the third number is the <em>patch</em> version, and this one indicates a change that is typically a bug fix or security fix. Each number <em>rolls over</em> like the seconds and minutes on a clock when the next version number is increased, i.e. you would go from version 2.7.23 to 3.0.0, or 4.3.12 to 4.4.0. For this project, each milestone should be treated as a minor release, and each new project as a major one.</p><p>Releases also get a human-readable name. For this class, you should use the assignment name as the release name, i.e. Milestone 0.</p><h2 id=step-4---submit-your-release-url-on-k-state-online>Step 4 - Submit your Release URL on K-State Online</h2><p>Once you have finished creating the release, GitHub should take you to the release page. You can also navigate there by clicking the specific release under the &ldquo;Releases&rdquo; heading on the right-hand side of your repository lannding page. Copy the URL of this page; it is what you will submit on Canvas.</p><p><a href=#R-image-a8200021c3b48e99d959e08cd145386b class=lightbox-link><img alt="Release URL" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.11.4.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a8200021c3b48e99d959e08cd145386b><img alt="Release URL" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.11.4.png></a></p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=adding-documentation-files>Adding Documentation Files</h1><p>When adding existing documentation files (i.e. UML documents) to your project, you may think adding them through Visual Studio&rsquo;s Solution Explorer would be the way to go. However, this can lead to an unexpected issue. Look closely at the example below:</p><p><a href=#R-image-4afc75ab36894aa88bffd2daaef1e52f class=lightbox-link><img alt="Bad Documentation Example" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.12.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-4afc75ab36894aa88bffd2daaef1e52f><img alt="Bad Documentation Example" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.12.1.png></a></p><p>We can see the PDF has been added to the solution file in the Solution Explorer, and we can see its raw data open in the editing pane. But take a close look at the Properties. The file is located in the Downloads folder! Since the file is not present in a folder managed by Git, <strong>IT WILL NOT BE COMMITTED!</strong></p><p>The <em>ONLY</em> way to get Git to track a file is to <em>PUT IT INTO A DIRECTORY TRACKED BY GIT</em>. Visual Studio&rsquo;s Solution Explorer does <em>NOT</em> copy existing PDF files, it simply creates a virtual representation of the file within the solution that points to where that file exists on your filesystem.</p><h2 id=open-the-solution-in-file-explorer>Open the Solution in File Explorer</h2><p>To summarize, you must <em>move or copy</em> the file you want to share into the solution directory using your operating system&rsquo;s file system, <em>NOT VISUAL STUDIO</em>. Visual Studio typically places your projects in the directory <code>C:/Users/%username%/source/repos/%solutionname%/</code> where <code>%username%</code> is your Windows username and <code>%solutionname%</code> is your solution&rsquo;s name. If you asked Visual Studio to save your files in another location, you need to look there.</p><p>However, there is a quick way to open the exact solution folder from within Visual Studio. Right-click the solution in the Solution Explorer and choose <strong>Open Folder in File Explorer</strong> from the context menu:</p><p><a href=#R-image-e3d1c0ff864813de08e67eeb8aa7610c class=lightbox-link><img alt="Open Folder in File Explorer" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.12.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e3d1c0ff864813de08e67eeb8aa7610c><img alt="Open Folder in File Explorer" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.12.2.png></a></p><p>Then you can use File Explorer to create your Documentation folder and place your documents:</p><p><a href=#R-image-9ae0f0f0eb868fdf6856920f0ebdc304 class=lightbox-link><img alt="Copy File into Documentation Folder" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.12.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-9ae0f0f0eb868fdf6856920f0ebdc304><img alt="Copy File into Documentation Folder" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.12.3.png></a></p><p>Once the document is in place, you will need to <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/05-staging-and-committing/#committing rel=external target=_blank>commit your changes</a> and <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/09-remote-repositories/#pushing rel=external target=_blank>push them to GitHub</a></p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis400/commit/681e5c9c43e3ac6de614c2cc74487702fd43cab7>Aug 10, 2023</a></p></div></div><script src=/cis400/js/clipboard.min.js?1724766102 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1724766102 defer></script><script src=/cis400/js/theme.js?1724766102 defer></script></body></html>