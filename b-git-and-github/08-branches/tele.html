<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="YouTube Video Branches are a powerful mechanisms for working on different versions of your code. The name “branch” is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:
This default branch was historically named “master”, though recent practice has shifted to using the term “main”."><meta name=author content="Nathan Bean"><meta name=twitter:card content="summary"><meta name=twitter:title content="Branches :: K-State CIS 400 Textbook"><meta name=twitter:description content="YouTube Video Branches are a powerful mechanisms for working on different versions of your code. The name “branch” is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:
This default branch was historically named “master”, though recent practice has shifted to using the term “main”."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis400/b-git-and-github/08-branches/"><meta property="og:site_name" content="K-State CIS 400 Textbook"><meta property="og:title" content="Branches :: K-State CIS 400 Textbook"><meta property="og:description" content="YouTube Video Branches are a powerful mechanisms for working on different versions of your code. The name “branch” is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:
This default branch was historically named “master”, though recent practice has shifted to using the term “main”."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Git and GitHub"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2024-06-27T14:36:54-05:00"><meta itemprop=name content="Branches :: K-State CIS 400 Textbook"><meta itemprop=description content="YouTube Video Branches are a powerful mechanisms for working on different versions of your code. The name “branch” is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:
This default branch was historically named “master”, though recent practice has shifted to using the term “main”."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2024-06-27T14:36:54-05:00"><meta itemprop=wordCount content="768"><title>Branches :: K-State CIS 400 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/08-branches/ rel=canonical type=text/html title="Branches :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/08-branches/index.xml rel=alternate type=application/rss+xml title="Branches :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/08-branches/index.print.html rel=alternate type=text/html title="Branches :: K-State CIS 400 Textbook"><link href=/cis400/b-git-and-github/08-branches/embed.html rel=alternate type=text/html title="Branches :: K-State CIS 400 Textbook"><link href=/cis400/css/fontawesome-all.min.css?1724857982 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fontawesome-all.min.css?1724857982 rel=stylesheet></noscript><link href=/cis400/css/nucleus.css?1724857982 rel=stylesheet><link href=/cis400/css/auto-complete.css?1724857982 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/auto-complete.css?1724857982 rel=stylesheet></noscript><link href=/cis400/css/perfect-scrollbar.min.css?1724857982 rel=stylesheet><link href=/cis400/css/fonts.css?1724857982 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis400/css/fonts.css?1724857982 rel=stylesheet></noscript><link href=/cis400/css/theme.css?1724857982 rel=stylesheet><link href=/cis400/css/theme-auto.css?1724857982 rel=stylesheet id=R-variant-style><link href=/cis400/css/chroma-auto.css?1724857982 rel=stylesheet id=R-variant-chroma-style><link href=/cis400/css/variant.css?1724857982 rel=stylesheet><link href=/cis400/css/print.css?1724857982 rel=stylesheet media=print><script src=/cis400/js/variant.js?1724857982></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis400",window.index_js_url="/cis400/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis400/css/custom.css?1724857982 rel=stylesheet></head><body class="mobile-support tele disableInlineCopyToClipboard" data-url=/cis400/b-git-and-github/08-branches/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=branches>Branches</h1><a href="https://www.youtube.com/watch?v=dPzLr53-Geg">YouTube Video</a><p>Branches are a powerful mechanisms for working on different versions of your code. The name &ldquo;branch&rdquo; is derived from visualizing a repository as a tree structure, with each commit being a node in the tree. For a simple repository, this tree structure is pretty boring - just a straight line as each node has only one child:</p><p><a href=#R-image-b42507f0b826a8dc83a7f0e52920ba2b class=lightbox-link><img alt="Simple repository with one branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.1.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b42507f0b826a8dc83a7f0e52920ba2b><img alt="Simple repository with one branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.1.png></a></p><p>This default branch was historically named &ldquo;master&rdquo;, though recent practice has shifted to using the term &ldquo;main&rdquo;. GitHub provides <a href=https://github.com/github/renaming rel=external target=_blank>guidance and support for renaming existing project branches</a>.</p><p>At any node in the commit tree, we could create a new branching point with the command <strong>git branch [branchname]</strong> where we supply the branch name. The branch starts with exactly the same code as the current commit to main (or whatever branch we are branching from). Then we can check out the branch with <strong>git checkout [branchname]</strong>, using the name we supplied. Let&rsquo;s create and check out a branch named &ldquo;experiment&rdquo; in our above example:</p><div class=highlight><pre tabindex=0><code>$ git branch experiment
$ git checkout experiment</code></pre></div><p>We now have a new branch, experiment, branching from commit <strong>573ed9f</strong>:</p><p><a href=#R-image-6a8b5303572d90173f10c406f6a553a2 class=lightbox-link><img alt="The same repository with a new branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.2.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6a8b5303572d90173f10c406f6a553a2><img alt="The same repository with a new branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.2.png></a></p><p>While &ldquo;experiment&rdquo; is the checked out branch, any commits we make are placed on it instead of the main branch. Let&rsquo;s assume we create two commits on the experiment branch; our tree will now look like:</p><p><a href=#R-image-687fc8902f73bc9e7e5dd3696a36ab93 class=lightbox-link><img alt="Two commits on the experimental branch" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis400/images/b.8.3.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-687fc8902f73bc9e7e5dd3696a36ab93><img alt="Two commits on the experimental branch" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis400/images/b.8.3.png></a></p><p>We can switch back to the main branch at any point with <strong>git checkout main</strong>. When we do so, our code will be reverted back to how it was in the last commit to the main branch (commit <strong>573ed9f</strong>). If it turns out our experiment was a flop, we can forget about the experiment branch and the changes we made to it - we&rsquo;re back to a clean working build at the point before we started the experiment.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Info</div><div class=box-content><p>It is important to understand how commits and branches interact. When you check out a branch, the code in the repository is reverted to the last commit on that branch. And any new commits you make are saved to the currently checked out branch.</p><p>If you have <em>uncommitted</em> or <em>staged</em> changes in files, git will refuse to check out a branch until these are committed or stashed, as checking out the branch will overwrite those changes and they would be lost forever. In contrast, <em>unstaged</em> and <em>ignored</em> files are fine (as there is no committed version that will overwrite the file). Best practice is to commit your changes before switching branches, unless you want to throw the changes away.</p></div></div><p>If, on the other hand, we like the changes from the experiment, and want to add them to the main branch, we can <em>merge</em> those changes with the <strong>git merge [branchname]</strong> command:</p><div class=highlight><pre tabindex=0><code>$ git merge experiment</code></pre></div><p>This merges the specified branch with the currently checked-out branch. Git accomplishes merging through a recursive strategy, which works very well. However, if both branches have had changes committed since the last shared commit, there is a possibility that some of those changes will overlap, and Git will not be able to determine which to use. This is called a <em>merge conflict</em> and must be resolved by you. See the <a href=https://textbooks.cs.ksu.edu/cis400/b-git-and-github/11-merge-conflicts/ rel=external target=_blank>merge conflict</a> section later for more details.</p><p>There are a number of reasons we might want to create a branch; let&rsquo;s examine some common use cases.</p><ul><li><p>Prototype branches - Let&rsquo;s say we wanted to try making some changes to our code that we aren&rsquo;t sure will work - basically, we are creating an experimental prototype. If this experiment doesn&rsquo;t end up succeeding, we would like to return to our current version of the project. This is exactly the scenario we walked through above.</p></li><li><p>Feature branches - Let&rsquo;s assume you have a working program you need to add a new feature to, but you still want to be able to access the working code. In this case, you can create a branch to work on that feature. That way, when your feature is only partially done, you can still switch back to your main branch and fix a bug, etc., without needing to remove or comment out your half-written feature code.</p></li><li><p>Personal branches - Let&rsquo;s say you&rsquo;re working with a team. You want to make sure that the main branch is always clean, ready-to-go code, and you don&rsquo;t want to have to deal with your teammate&rsquo;s half-written code (nor they with yours). Each team member can create their own branch to do their work on, and when it is tested and ready, merge that code into the main branch.</p></li></ul><p>Each of these approaches can (and usually is) used in conjunction with remote repositories. We&rsquo;ll take a look at that next.</p><footer class=footline></footer></article></div></main></div></div><script src=/cis400/js/clipboard.min.js?1724857982 defer></script><script src=/cis400/js/perfect-scrollbar.min.js?1724857982 defer></script><script src=/cis400/js/theme.js?1724857982 defer></script><script src=/cis400/js/tele-scroll.js?1724857982 defer></script></body></html>